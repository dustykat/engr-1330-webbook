{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CTDS Databases For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#ctds-databases","text":"For full documentation visit mkdocs.org .","title":"CTDS Databases"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"untitled/","text":"","title":"Databases"},{"location":"conditional-block-if/conditional-block-if/","text":"IF ... (block structure) Conditional Execution Decision making via conditional statements is an important step in algorithm design; they control the flow of execution of a program. Conditional statements in Python include: if conditional statement : do something if....else conditional statement(s) : do something, or do something else if....elif....else conditional statement(s) : do something, or do something else, ... , or do something else Conditional statements are logical expressions that evaluate as TRUE or FALSE and using these results to perform further operations based on these conditions. All flow control in a program depends on evaluating conditions. The program will proceed diferently based on the outcome of one or more conditions - really sophisticated AI programs are a collection of conditions and correlations. Logical Comparison Statements The most common conditional operation is comparison. If we wish to compare whether two variables are the same we use the == (double equal sign). For example x == y means the program will ask whether x and y have the same value. If they do, the result is TRUE if not then the result is FALSE. Other comparison signs are != does NOT equal, < smaller than, > larger than, <= less than or equal, and >= greater than or equal. There are also three logical operators when we want to build multiple compares (multiple conditioning); these are and , or , and not . The and operator returns TRUE if (and only if) all conditions are TRUE. For instance 5 == 5 and 5 < 6 will return a TRUE because both conditions are true. The or operator returns TRUE if at least one condition is true. If all conditions are FALSE, then it will return a FALSE. For instance 4 > 3 or 17 > 20 or 3 == 2 will return TRUE because the first condition is true. The not operator returns TRUE if the condition after the not keyword is false. Think of it as a way to do a logic reversal. # Compare x = 7 y = 10 print(\"x =: \",x,\"y =: \",y) print(\"x is equal to y : \",x==y) print(\"x is not equal to y : \",x!=y) print(\"x is greater than y : \",x>y) print(\"x is less than y : \",x<y) x =: 7 y =: 10 x is equal to y : False x is not equal to y : True x is greater than y : False x is less than y : True # Logical operators print(\"5 == 5 and 5 < 6 ? \",5 == 5 and 5 < 6) print(\"4 > 3 or 17 > 20 \",4 > 3 or 17 > 20) print(\"not 5 == 5\",not 5 == 5) 5 == 5 and 5 < 6 ? True 4 > 3 or 17 > 20 True not 5 == 5 False Block IF statement The if statement is a common flow control statement. It allows the program to evaluate if a certain condition is satisfied and to perform a designed action based on the result of the evaluation. Expressed in a flowchart a block if statement looks like: As psuedo code: if(condition is true): do stuff Amazon knowing what you kind of want is based on correlations of your past behavior compared to other peoples similar, but more recent behavior, and then it uses conditional statements to decide what item to offer you in your recommendation items. It's spooky, but ultimately just a program running in the background trying to make your money theirs. The structure of a mutliple condition block if statement is if condition 1 is met: do A elif condition 2 is met: do B elif condition 3 is met: do C else: do E The elif means \"else if\". The : colon is an important part of the structure it tells where the action begins. Also there are no scope delimiters like (), or {} . Instead Python uses indentation to isolate blocks of code. This convention is hugely important - many other coding environments use delimiters (called scoping delimiters), but Python does not. The indentation itself is the scoping delimiter. The next code fragment illustrates illustrates how the if statements work. The program asks the user for input. The use of raw_input() will let the program read any input as a string so non-numeric results will not throw an error. The input is stored in the variable named userInput . Next the statement if userInput == \"1\": compares the value of userInput with the string \"1\" . If the value in the variable is indeed \\1\", then the program will execute the block of code in the indentation after the colon. In this case it will execute print \"Hello World\" print \"How do you do? \" Alternatively, if the value of userInput is the string '2' , then the program will execute print \"Snakes on a plane \" For all other values the program will execute print \"You did not enter a valid number\" # Block if example userInput = input('Enter the number 1 or 2') userInput = str(userInput) # type cast to string, to trap goofy binary/hex inputs # Use block if structure if userInput == '1': print(\"Hello World\") print(\"How do you do? \") elif userInput == '2': print(\"Snakes on a plane \") else: print(\"You did not enter a valid number\") When we run the script Enter the number 1 or 2 1 Hello World How do you do? Readings Computational and Inferential Thinking Ani Adhikari and John DeNero, Computational and Inferential Thinking, The Foundations of Data Science, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND) Chapter 4 Subpart 3 https://www.inferentialthinking.com/chapters/04/3/Comparison.html Computational and Inferential Thinking Ani Adhikari and John DeNero, Computational and Inferential Thinking, The Foundations of Data Science, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND) Chapter 4 https://www.inferentialthinking.com/chapters/04/Data_Types.html Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. LearnPython.org (Interactive Tutorial) (https://www.learnpython.org/) Short, interactive tutorial for those who just need a quick way to pick up Python syntax.","title":"IF ... (block structure)"},{"location":"conditional-block-if/conditional-block-if/#if-block-structure","text":"","title":"IF ... (block structure)"},{"location":"conditional-block-if/conditional-block-if/#conditional-execution","text":"Decision making via conditional statements is an important step in algorithm design; they control the flow of execution of a program. Conditional statements in Python include: if conditional statement : do something if....else conditional statement(s) : do something, or do something else if....elif....else conditional statement(s) : do something, or do something else, ... , or do something else Conditional statements are logical expressions that evaluate as TRUE or FALSE and using these results to perform further operations based on these conditions. All flow control in a program depends on evaluating conditions. The program will proceed diferently based on the outcome of one or more conditions - really sophisticated AI programs are a collection of conditions and correlations.","title":"Conditional Execution"},{"location":"conditional-block-if/conditional-block-if/#logical-comparison-statements","text":"The most common conditional operation is comparison. If we wish to compare whether two variables are the same we use the == (double equal sign). For example x == y means the program will ask whether x and y have the same value. If they do, the result is TRUE if not then the result is FALSE. Other comparison signs are != does NOT equal, < smaller than, > larger than, <= less than or equal, and >= greater than or equal. There are also three logical operators when we want to build multiple compares (multiple conditioning); these are and , or , and not . The and operator returns TRUE if (and only if) all conditions are TRUE. For instance 5 == 5 and 5 < 6 will return a TRUE because both conditions are true. The or operator returns TRUE if at least one condition is true. If all conditions are FALSE, then it will return a FALSE. For instance 4 > 3 or 17 > 20 or 3 == 2 will return TRUE because the first condition is true. The not operator returns TRUE if the condition after the not keyword is false. Think of it as a way to do a logic reversal. # Compare x = 7 y = 10 print(\"x =: \",x,\"y =: \",y) print(\"x is equal to y : \",x==y) print(\"x is not equal to y : \",x!=y) print(\"x is greater than y : \",x>y) print(\"x is less than y : \",x<y) x =: 7 y =: 10 x is equal to y : False x is not equal to y : True x is greater than y : False x is less than y : True # Logical operators print(\"5 == 5 and 5 < 6 ? \",5 == 5 and 5 < 6) print(\"4 > 3 or 17 > 20 \",4 > 3 or 17 > 20) print(\"not 5 == 5\",not 5 == 5) 5 == 5 and 5 < 6 ? True 4 > 3 or 17 > 20 True not 5 == 5 False","title":"Logical Comparison Statements"},{"location":"conditional-block-if/conditional-block-if/#block-if-statement","text":"The if statement is a common flow control statement. It allows the program to evaluate if a certain condition is satisfied and to perform a designed action based on the result of the evaluation. Expressed in a flowchart a block if statement looks like: As psuedo code: if(condition is true): do stuff Amazon knowing what you kind of want is based on correlations of your past behavior compared to other peoples similar, but more recent behavior, and then it uses conditional statements to decide what item to offer you in your recommendation items. It's spooky, but ultimately just a program running in the background trying to make your money theirs. The structure of a mutliple condition block if statement is if condition 1 is met: do A elif condition 2 is met: do B elif condition 3 is met: do C else: do E The elif means \"else if\". The : colon is an important part of the structure it tells where the action begins. Also there are no scope delimiters like (), or {} . Instead Python uses indentation to isolate blocks of code. This convention is hugely important - many other coding environments use delimiters (called scoping delimiters), but Python does not. The indentation itself is the scoping delimiter. The next code fragment illustrates illustrates how the if statements work. The program asks the user for input. The use of raw_input() will let the program read any input as a string so non-numeric results will not throw an error. The input is stored in the variable named userInput . Next the statement if userInput == \"1\": compares the value of userInput with the string \"1\" . If the value in the variable is indeed \\1\", then the program will execute the block of code in the indentation after the colon. In this case it will execute print \"Hello World\" print \"How do you do? \" Alternatively, if the value of userInput is the string '2' , then the program will execute print \"Snakes on a plane \" For all other values the program will execute print \"You did not enter a valid number\" # Block if example userInput = input('Enter the number 1 or 2') userInput = str(userInput) # type cast to string, to trap goofy binary/hex inputs # Use block if structure if userInput == '1': print(\"Hello World\") print(\"How do you do? \") elif userInput == '2': print(\"Snakes on a plane \") else: print(\"You did not enter a valid number\") When we run the script Enter the number 1 or 2 1 Hello World How do you do?","title":"Block IF statement"},{"location":"conditional-block-if/conditional-block-if/#readings","text":"Computational and Inferential Thinking Ani Adhikari and John DeNero, Computational and Inferential Thinking, The Foundations of Data Science, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND) Chapter 4 Subpart 3 https://www.inferentialthinking.com/chapters/04/3/Comparison.html Computational and Inferential Thinking Ani Adhikari and John DeNero, Computational and Inferential Thinking, The Foundations of Data Science, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND) Chapter 4 https://www.inferentialthinking.com/chapters/04/Data_Types.html Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. LearnPython.org (Interactive Tutorial) (https://www.learnpython.org/) Short, interactive tutorial for those who just need a quick way to pick up Python syntax.","title":"Readings"},{"location":"repetition-for-loop/repetition-for-loop/","text":"FOR ... loop Count controlled repetition structure Count-controlled repetition is also called definite repetition because the number of repetitions is known before the loop begins executing. When we do not know in advance the number of times we want to execute a statement, count-controlled repetition becomes a challenge, instead we would use sentinel-controlled repetition. A count-controlled repetition will exit after running a certain number of times. The count is kept in a variable called an index or counter. When the index reaches a certain value (the loop bound) the loop will end. Count-controlled repetition requires control variable (or loop counter) initial value of the control variable increment (or decrement) by which the control variable is modified each iteration through the loop condition that tests for the final value of the control variable We can use both for and while loops, for count controlled repetition, but the for loop in combination with the range() function is more common. Structured FOR loop We have seen the for loop already, but we will formally introduce it here. The for loop executes a block of code repeatedly until the condition in the for statement is no longer true. Looping through an iterable An iterable is anything that can be looped over - typically a list, string, or tuple. The syntax for looping through an iterable is illustrated by an example. First a generic syntax for a in iterable: print(a) Notice our friends the colon : and the indentation. The range() function to create an iterable The range(begin,end,increment) function will create an iterable starting at a value of begin, in steps defined by increment ( begin += increment ), ending at end . So a generic syntax becomes for a in range(begin,end,increment): print(a) The examples that follow are count-controlled repetition (increment skip if greater) Example for loops # sum numbers from 1 to n howmany = int(input('Enter N')) accumulator = 0.0 for i in range(1,howmany+1,1): accumulator = accumulator + float(i) print( 'Sum from 1 to ',howmany, 'is %.3f' % accumulator ) Enter N 3 Sum from 1 to 3 is 6.000 # sum even numbers from 1 to n howmany = int(input('Enter N')) accumulator = 0.0 for i in range(1,howmany+1,1): if i%2 == 0: accumulator = accumulator + float(i) print( 'Sum of Evens from 1 to ',howmany, 'is %.3f' % accumulator ) Enter N 3 Sum of Evens from 1 to 3 is 2.000 howmany = int(input('Enter N')) linetoprint='' for i in range(1,howmany+1,1): linetoprint=linetoprint + '*' print(linetoprint) Enter N 3 * ** *** howmany = int(input('Enter N')) linetoprint='' myiterable = range(1,howmany+1,1) # using range to make an iterable for i in myiterable: linetoprint=linetoprint + '*' print(linetoprint) Enter N 33 * ** *** **** ***** ****** ******* ******** ********* ********** *********** ************ ************* ************** *************** **************** ***************** ****************** ******************* ******************** ********************* ********************** *********************** ************************ ************************* ************************** *************************** **************************** ***************************** ****************************** ******************************* ******************************** ********************************* References Computational and Inferential Thinking Ani Adhikari and John DeNero, Computational and Inferential Thinking, The Foundations of Data Science, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND) Chapters 3-6 https://www.inferentialthinking.com/chapters/03/programming-in-python.html Learn Python the Hard Way (Online Book) https://learnpythonthehardway.org/book/ Recommended for beginners who want a complete course in programming with Python. LearnPython.org (Interactive Tutorial) https://www.learnpython.org/ Short, interactive tutorial for those who just need a quick way to pick up Python syntax. Brian Christian and Tom Griffiths (2016) ALGORITHMS TO LIVE BY: The Computer Science of Human Decisions Henry Holt and Co. https://www.amazon.com/Algorithms-Live-Computer-Science-Decisions/dp/1627790365","title":"FOR ... loop"},{"location":"repetition-for-loop/repetition-for-loop/#for-loop","text":"","title":"FOR ... loop"},{"location":"repetition-for-loop/repetition-for-loop/#count-controlled-repetition-structure","text":"Count-controlled repetition is also called definite repetition because the number of repetitions is known before the loop begins executing. When we do not know in advance the number of times we want to execute a statement, count-controlled repetition becomes a challenge, instead we would use sentinel-controlled repetition. A count-controlled repetition will exit after running a certain number of times. The count is kept in a variable called an index or counter. When the index reaches a certain value (the loop bound) the loop will end. Count-controlled repetition requires control variable (or loop counter) initial value of the control variable increment (or decrement) by which the control variable is modified each iteration through the loop condition that tests for the final value of the control variable We can use both for and while loops, for count controlled repetition, but the for loop in combination with the range() function is more common.","title":"Count controlled repetition structure"},{"location":"repetition-for-loop/repetition-for-loop/#structured-for-loop","text":"We have seen the for loop already, but we will formally introduce it here. The for loop executes a block of code repeatedly until the condition in the for statement is no longer true.","title":"Structured FOR loop"},{"location":"repetition-for-loop/repetition-for-loop/#looping-through-an-iterable","text":"An iterable is anything that can be looped over - typically a list, string, or tuple. The syntax for looping through an iterable is illustrated by an example. First a generic syntax for a in iterable: print(a) Notice our friends the colon : and the indentation.","title":"Looping through an iterable"},{"location":"repetition-for-loop/repetition-for-loop/#the-range-function-to-create-an-iterable","text":"The range(begin,end,increment) function will create an iterable starting at a value of begin, in steps defined by increment ( begin += increment ), ending at end . So a generic syntax becomes for a in range(begin,end,increment): print(a) The examples that follow are count-controlled repetition (increment skip if greater)","title":"The range() function to create an iterable"},{"location":"repetition-for-loop/repetition-for-loop/#example-for-loops","text":"# sum numbers from 1 to n howmany = int(input('Enter N')) accumulator = 0.0 for i in range(1,howmany+1,1): accumulator = accumulator + float(i) print( 'Sum from 1 to ',howmany, 'is %.3f' % accumulator ) Enter N 3 Sum from 1 to 3 is 6.000 # sum even numbers from 1 to n howmany = int(input('Enter N')) accumulator = 0.0 for i in range(1,howmany+1,1): if i%2 == 0: accumulator = accumulator + float(i) print( 'Sum of Evens from 1 to ',howmany, 'is %.3f' % accumulator ) Enter N 3 Sum of Evens from 1 to 3 is 2.000 howmany = int(input('Enter N')) linetoprint='' for i in range(1,howmany+1,1): linetoprint=linetoprint + '*' print(linetoprint) Enter N 3 * ** *** howmany = int(input('Enter N')) linetoprint='' myiterable = range(1,howmany+1,1) # using range to make an iterable for i in myiterable: linetoprint=linetoprint + '*' print(linetoprint) Enter N 33 * ** *** **** ***** ****** ******* ******** ********* ********** *********** ************ ************* ************** *************** **************** ***************** ****************** ******************* ******************** ********************* ********************** *********************** ************************ ************************* ************************** *************************** **************************** ***************************** ****************************** ******************************* ******************************** *********************************","title":"Example for loops"},{"location":"repetition-for-loop/repetition-for-loop/#references","text":"Computational and Inferential Thinking Ani Adhikari and John DeNero, Computational and Inferential Thinking, The Foundations of Data Science, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND) Chapters 3-6 https://www.inferentialthinking.com/chapters/03/programming-in-python.html Learn Python the Hard Way (Online Book) https://learnpythonthehardway.org/book/ Recommended for beginners who want a complete course in programming with Python. LearnPython.org (Interactive Tutorial) https://www.learnpython.org/ Short, interactive tutorial for those who just need a quick way to pick up Python syntax. Brian Christian and Tom Griffiths (2016) ALGORITHMS TO LIVE BY: The Computer Science of Human Decisions Henry Holt and Co. https://www.amazon.com/Algorithms-Live-Computer-Science-Decisions/dp/1627790365","title":"References"},{"location":"repetition-while-loop/repetition-while-loop/","text":"WHILE ... loop Sentinel-controlled repetition. When loop control is based on the value of what we are processing, sentinel-controlled repetition is used. Sentinel-controlled repetition is also called indefinite repetition because it is not known in advance how many times the loop will be executed. It is a repetition procedure for solving a problem by using a sentinel value (also called a signal value, a dummy value or a flag value) to indicate \"end of process\". The sentinel value itself need not be a part of the processed data. One common example of using sentinel-controlled repetition is when we are processing data from a file and we do not know in advance when we would reach the end of the file. We can use both for and while loops, for Sentinel controlled repetition, but the while loop is more common. Structured WHILE loop The while loop repeats a block of instructions inside the loop while a condition remainsvtrue. First a generic syntax while condition is true: execute a execute b .... Notice our friends the colon : and the indentation again. Example while loops # sum numbers from 1 to n howmany = int(input('Enter N')) accumulator = 0.0 counter = 1 while counter <= howmany: accumulator = accumulator + float(counter) counter += 1 print( 'Sum from 1 to ',howmany, 'is %.3f' % accumulator ) Enter N 3 Sum from 1 to 3 is 6.000 # sum even numbers from 1 to n howmany = int(input('Enter N')) accumulator = 0.0 counter = 1 while counter <= howmany: if counter%2 == 0: accumulator = accumulator + float(counter) counter += 1 print( 'Sum of Evens 1 to ',howmany, 'is %.3f' % accumulator ) Enter N 33 Sum of Evens 1 to 33 is 272.000 howmany = int(input('Enter N')) linetoprint='' counter = 1 while counter <= howmany: linetoprint=linetoprint + '*' counter += 1 print(linetoprint) Enter N 33 * ** *** **** ***** ****** ******* ******** ********* ********** *********** ************ ************* ************** *************** **************** ***************** ****************** ******************* ******************** ********************* ********************** *********************** ************************ ************************* ************************** *************************** **************************** ***************************** ****************************** ******************************* ******************************** ********************************* References Computational and Inferential Thinking Ani Adhikari and John DeNero, Computational and Inferential Thinking, The Foundations of Data Science, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND) Chapters 3-6 https://www.inferentialthinking.com/chapters/03/programming-in-python.html Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. LearnPython.org (Interactive Tutorial) (https://www.learnpython.org/) Short, interactive tutorial for those who just need a quick way to pick up Python syntax. Brian Christian and Tom Griffiths (2016) ALGORITHMS TO LIVE BY: The Computer Science of Human Decisions Henry Holt and Co. (https://www.amazon.com/Algorithms-Live-Computer-Science-Decisions/dp/1627790365)","title":"WHILE ... loop"},{"location":"repetition-while-loop/repetition-while-loop/#while-loop","text":"","title":"WHILE ... loop"},{"location":"repetition-while-loop/repetition-while-loop/#sentinel-controlled-repetition","text":"When loop control is based on the value of what we are processing, sentinel-controlled repetition is used. Sentinel-controlled repetition is also called indefinite repetition because it is not known in advance how many times the loop will be executed. It is a repetition procedure for solving a problem by using a sentinel value (also called a signal value, a dummy value or a flag value) to indicate \"end of process\". The sentinel value itself need not be a part of the processed data. One common example of using sentinel-controlled repetition is when we are processing data from a file and we do not know in advance when we would reach the end of the file. We can use both for and while loops, for Sentinel controlled repetition, but the while loop is more common.","title":"Sentinel-controlled repetition."},{"location":"repetition-while-loop/repetition-while-loop/#structured-while-loop","text":"The while loop repeats a block of instructions inside the loop while a condition remainsvtrue. First a generic syntax while condition is true: execute a execute b .... Notice our friends the colon : and the indentation again.","title":"Structured WHILE loop"},{"location":"repetition-while-loop/repetition-while-loop/#example-while-loops","text":"# sum numbers from 1 to n howmany = int(input('Enter N')) accumulator = 0.0 counter = 1 while counter <= howmany: accumulator = accumulator + float(counter) counter += 1 print( 'Sum from 1 to ',howmany, 'is %.3f' % accumulator ) Enter N 3 Sum from 1 to 3 is 6.000 # sum even numbers from 1 to n howmany = int(input('Enter N')) accumulator = 0.0 counter = 1 while counter <= howmany: if counter%2 == 0: accumulator = accumulator + float(counter) counter += 1 print( 'Sum of Evens 1 to ',howmany, 'is %.3f' % accumulator ) Enter N 33 Sum of Evens 1 to 33 is 272.000 howmany = int(input('Enter N')) linetoprint='' counter = 1 while counter <= howmany: linetoprint=linetoprint + '*' counter += 1 print(linetoprint) Enter N 33 * ** *** **** ***** ****** ******* ******** ********* ********** *********** ************ ************* ************** *************** **************** ***************** ****************** ******************* ******************** ********************* ********************** *********************** ************************ ************************* ************************** *************************** **************************** ***************************** ****************************** ******************************* ******************************** *********************************","title":"Example while loops"},{"location":"repetition-while-loop/repetition-while-loop/#references","text":"Computational and Inferential Thinking Ani Adhikari and John DeNero, Computational and Inferential Thinking, The Foundations of Data Science, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND) Chapters 3-6 https://www.inferentialthinking.com/chapters/03/programming-in-python.html Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. LearnPython.org (Interactive Tutorial) (https://www.learnpython.org/) Short, interactive tutorial for those who just need a quick way to pick up Python syntax. Brian Christian and Tom Griffiths (2016) ALGORITHMS TO LIVE BY: The Computer Science of Human Decisions Henry Holt and Co. (https://www.amazon.com/Algorithms-Live-Computer-Science-Decisions/dp/1627790365)","title":"References"},{"location":"solved-integration/NumericalIntegration/","text":"Numerical Integration of Functional Data At this point we have enough Python to consider doing some useful computations. We will start with numerical integration because it is useful and only requires count-controlled repetition and single subscript lists. Background Numerical integration is the numerical approximation of \\begin{equation} I = \\int_a^b f(x)dx \\end{equation} Consider the problem of determining the shaded area under the curve y = f(x) from x = a to x = b , as depicted in the figure below, and suppose that analytical integration is not feasible. Aside: How to embed a figure 1) Upload the file to the notebook directory, for this kind of environment use .png, .jpg 2) Use the markdown syntax ![](figure-filename). I used \"![figure1](panels.png)\" 3) The [] is a tag delimiter, I dont know how to use tags yet, its not a caption (bummer!) The function may be known in tabular form from experimental measurements or it may be known in an analytical form. The function is taken to be continuous within the interval a < x < b . We may divide the area into n vertical panels, each of width \\Delta x = (b - a)/n , and then add the areas of all strips to obtain A~\\approx \\int ydx . A representative panel of area A_i is shown with darker shading in the figure. Three useful numerical approximations are listed in the following sections. The approximations differ in how the function is represented by the panels --- in all cases the function is approximated by known polynomial models between the panel end points. In each case the greater the number of strips, and correspondingly smaller value of \\Delta x , the more accurate the approximation. Typically, one can begin with a relatively small number of panels and increase the number until the resulting area approximation stops changing. Rectangular Panels -- in primatives A primative is a structure built with the base python language and avoids packages, in my work it is obvious, the import package.name is absent in the source code. The figure below is a schematic of a rectangular panels. The figure is assuming the function structure is known and can be evaluated at an arbitrary location in the \\Delta x dimension. Each panel is treated as a rectangle, as shown by the representative panel whose height y_m is chosen visually so that the small cross-hatched areas are as nearly equal as possible. Thus, we form the sum \\sum y_m of the effective heights and multiply by \\Delta x . For a function known in analytical form, a value for y_m equal to that of the function at the midpoint x_i + \\Delta x /2 may be calculated and used in the summation. For tabulated functions, we have to choose to either take y_m as the value at the left endpoint or right endpoint. This limitation is often quite handy when we are trying to integrate a function that is integrable, but undefined on one endpoint. Lets try some examples in Python. Find the area under the curve y= x\\sqrt{1+x^2} from x = 0 to x = 2 . First lets read in the value for the lowerlimit, we will do some limited error checks to be sure user enters a number, but won't check that the number is non-negative. # RectangularPanels.py # Numerical Integration print (\"Program finds area under curve y = x * sqrt(1+x)\") # Get input data -- use error checking yes = 0 while yes == 0: x_low = input(\"Enter a lower bound x_low \\n\") try: x_low = float(x_low) yes = 1 except: print (\"x_low really needs to be a number, try again \\n\") # exit the while loop when finally have a valid number Program finds area under curve y = x * sqrt(1+x) Verify that value is indeed what we entered print(x_low) Now do the same for the upper limit, notice how we are using the yes variable. We set a \"fail\" value, and demand input until we get \"success\". The structure used here is called a try -- exception structure and is very common in programming. Error checking is really important so that garbled input does not hang things up. yes = 0 while yes == 0: x_high = input(\"Enter an upper bound x_high \\n\") try: x_high = float(x_high) yes = 1 except: print (\"x_high really needs to be a number, try again \\n\") # exit the while loop when finally have a valid number Again verify! print(x_high) Now use the try - exception structure to input how many panels we wish to use. Notice you can enter a negative value which will ultimately break things. Also observe this value is an integer. yes = 0 while yes == 0: how_many = input(\"Enter how many panels \\n\") try: how_many = int(how_many) yes = 1 except: print (\"Panels really needs to be a number, try again \\n\") # exit the while loop when finally have a valid number Again verify! print(how_many) Now we can actually perform the integration by evaluating the function at the panel half-widths. In this example we are using primitive arithmetic, so the \\sqrt{} is accomplished by exponentation, the syntax is c = a ** b is the operation c = a^b . The integration uses an accumulator, which is a memory location where subsquent results are added (accumulated) back into the accumulator. This structure is so common that there are alternate, compact syntax to perform this task, here it is all out in the open. The counting loop where we evaluate the function at different x values, starts at 1 and ends at how_many+1 because python for loops use an increment skip if equal structure. When the value in range equals how_many the for loop exits ( break is implied.) A loop control structure starting from 0 is shown in the code as a comment line. Simply uncomment this line, and comment the line just below to have the structure typical in python scripts. In the start from 1 case, we want to evaluate at the last value of how_many . # OK we should have the three things we need for evaluating the integral delta_x = (x_high - x_low)/float(how_many) # compute panel width xx = x_low + delta_x/2 # initial value for x ### OK THIS IS THE ACTUAL INTEGRATOR PART ### accumulated_area = 0.0 # initial value in an accumulator #for i in range(0,how_many,1): #note we are counting from 0 for i in range(1,how_many+1,1): #note we are counting from 1 accumulated_area = accumulated_area + ( xx * ( (1+xx**2)**(0.5) ) ) * delta_x xx = xx + delta_x ### AND WE ARE DONE INTEGRATING ############# Finally, we want to report our result print (\"Area under curve y = x * sqrt(1+x) from x = \",x_low,\\ \" to x = \",x_high,\"\\n is approximately: \",accumulated_area) # the backslash \\ # \" to x = ..... lets us use multiple lines # the \\n is a \"newline\" character The code implements rudimentary error checking -- it forces us to enter numeric values for the lower and upper values of x as well as the number of panels to use. It does not check for undefined ranges and such, but you should get the idea -- notice that a large fraction of the entire program is error trapping; this devotion to error trapping is typical for professional programs where you are going to distribute executable modules and not expect the end user to be a programmer. Using the math package The actual computations are done rather crudely -- there is a math package that would give us the ability to compute the square root as a function call rather than exponentiation to a real values exponent. That is illustrated below # RectangularPanels.py # Numerical Integration # Use built-in math functions import math # a package of math functions # we are naming an object \"sqrt\" that will compute the square root def sqrt (x): return math.sqrt(x) # saves us having to type math.NAME every time we wish to use a function # in this program not all that meaningful, but in complex programs handy! print (\"Program finds area under curve y = x * sqrt(1+x)\") # Get input data -- use error checking yes = 0 while yes == 0: x_low = input(\"Enter a lower bound x_low \\n\") try: x_low = float(x_low) yes = 1 except: print (\"x_low really needs to be a number, try again \\n\") yes = 0 while yes == 0: x_high = input(\"Enter an upper bound x_high \\n\") try: x_high = float(x_high) yes = 1 except: print (\"x_high really needs to be a number, try again \\n\") yes = 0 while yes == 0: how_many = input(\"Enter how many panels \\n\") try: how_many = int(how_many) yes = 1 except: print (\"Panels really needs to be a number, try again \\n\") delta_x = (x_high - x_low)/float(how_many) # compute panel width accumulated_area = 0.0 # initial value in an accumulator xx = x_low + delta_x/2 # initial value for x for i in range(1,how_many+1,1): #note we are counting from 1 accumulated_area = accumulated_area + ( xx * sqrt(1+xx**2) ) * delta_x xx = xx + delta_x print (\"Area under curve y = x * sqrt(1+x) from x = \",x_low,\\ \" to x = \",x_high,\"\\n is approximately: \",accumulated_area) Trapezoidal Panels The trapezoidal panels are approximated as shown in the figure below. The area A_i is the average height (y_i + y_{i+1} )/2 times \\Delta x . Adding the areas gives the area approximation as tabulated. For the example with the curvature shown, the approximation will be on the low side. For the reverse curvature, the approximation will be on the high side. The trapezoidal approximation is commonly used with tabulated values. The script below illustrates the trapezoidal method for approximating an integral. In the example, the left and right panel endpoints in x are set as separate variables x_{left} and x_{right} and incremented by \\Delta x as we step through the count-controlled repetition to accumulate the area. The corresponding y values are computed within the loop and averaged, then multiplied by \\Delta x and added to the accumulator. Finally the x values are incremented --- for grins, we used the += operator on the accumulator # TrapezoidalPanels.py # Numerical Integration # Use built-in math functions import math # a package of math functions # we are naming an object \"sqrt\" that will compute the square root def sqrt (x): return math.sqrt(x) # saves us having to type math.NAME every time we wish to use a function # in this program not all that meaningful, but in complex programs handy! print (\"Program finds area under curve y = x * sqrt(1+x)\") # Get input data -- use error checking yes = 0 while yes == 0: x_low = input(\"Enter a lower bound x_low \\n\") try: x_low = float(x_low) yes = 1 except: print (\"x_low really needs to be a number, try again \\n\") yes = 0 while yes == 0: x_high = input(\"Enter an upper bound x_high \\n\") try: x_high = float(x_high) yes = 1 except: print (\"x_high really needs to be a number, try again \\n\") yes = 0 while yes == 0: how_many = input(\"Enter how many panels \\n\") try: how_many = int(how_many) yes = 1 except: print (\"Panels really needs to be a number, try again \\n\") delta_x = (x_high - x_low)/float(how_many) # compute panel width accumulated_area = 0.0 # initial value in an accumulator x_left = x_low # initial value for x_left edge panel x_right = x_left + delta_x # initial value for x_right edge panel for i in range(1,how_many+1,1): #note we are counting from 1 y_left = ( x_left* sqrt(1+x_left**2) ) y_right = ( x_right* sqrt(1+x_right**2) ) accumulated_area += + (1./2.) * ( y_left + y_right ) * delta_x x_left += delta_x x_right += delta_x print (\"Area under curve y = x * sqrt(1+x) from x = \",x_low,\\ \" to x = \",x_high,\"\\n is approximately: \",accumulated_area) Parabolic Panels Parabolic panels approximate the shape of the panel with a parabola. The area between the chord and the curve (neglected in the trapezoidal solution) may be accounted for by approximating the function with a parabola passing through the points defined by three successive values of y . This area may be calculated from the geometry of the parabola and added to the trapezoidal area of the pair of strips to give the area \\Delta A of the pair as illustrated. Adding all of the \\Delta A s produces the tabulation shown, which is known as Simpson's rule. To use Simpson's rule, the number n of strips must be even. The same example as presented for rectangular panels is repeated, except using parabolic panels. The code is changed yet again because we will evaluate at each end of the panel as well as at an intermediate value. # ParabolicPanels.py # Numerical Integration # Use built-in math functions import math # a package of math functions # we are naming an object \"sqrt\" that will compute the square root def sqrt (x): return math.sqrt(x) # saves us having to type math.NAME every time we wish to use a function # in this program not all that meaningful, but in complex programs handy! print (\"Program finds area under curve y = x * sqrt(1+x)\") # Get input data -- use error checking yes = 0 while yes == 0: x_low = input(\"Enter a lower bound x_low \\n\") try: x_low = float(x_low) yes = 1 except: print (\"x_low really needs to be a number, try again \\n\") yes = 0 while yes == 0: x_high = input(\"Enter an upper bound x_high \\n\") try: x_high = float(x_high) yes = 1 except: print (\"x_high really needs to be a number, try again \\n\") yes = 0 while yes == 0: how_many = input(\"Enter how many panels \\n\") try: how_many = int(how_many) yes = 1 except: print (\"Panels really needs to be a number, try again \\n\") delta_x = (x_high - x_low)/float(how_many) # compute panel width accumulated_area = 0.0 # initial value in an accumulator x_left = x_low # initial value for x_left edge panel x_middle = x_left + delta_x # initial value for x_middle edge panel x_right = x_middle + delta_x # initial value for x_right edge panel how_many = int(how_many/2) # using 2 panels every step, so 1/2 many steps -- force integer result for i in range(1,how_many+1,1): #note we are counting from 1 y_left = ( x_left * sqrt(1+ x_left**2) ) y_middle = ( x_middle * sqrt(1+ x_middle**2) ) y_right = ( x_right * sqrt(1+ x_right**2) ) accumulated_area = accumulated_area + \\ (1./3.) * ( y_left + 4.* y_middle + y_right ) * delta_x x_left = x_left + 2*delta_x x_middle = x_left + delta_x x_right = x_middle + delta_x print (\"Area under curve y = x * sqrt(1+x) from x = \",x_low,\\ \" to x = \",x_high,\"\\n is approximately: \",accumulated_area) If we study all the forms of the numerical method we observe that the numerical integration method is really the sum of function values at specific locations in the interval of interest, with each value multiplied by a specific weight. In this development the weights were based on polynomials, but other method use different weighting functions. An extremely important method is called gaussian quadrature. This method is valuable because one can approximate convolution integrals quite effectively using quadrature routines, while the number of function evaluations for a polynomial based approximation could be hopeless. When the function values are tabular, we are going to have to accept the rectangular (with adaptations) and trapezoidal as our best tools to approximate an integral because we don't have any really effective way to evaluate the function between the tabulated values.","title":"Numerical Integration of Functional Data"},{"location":"solved-integration/NumericalIntegration/#numerical-integration-of-functional-data","text":"At this point we have enough Python to consider doing some useful computations. We will start with numerical integration because it is useful and only requires count-controlled repetition and single subscript lists.","title":"Numerical Integration of Functional Data"},{"location":"solved-integration/NumericalIntegration/#background","text":"Numerical integration is the numerical approximation of \\begin{equation} I = \\int_a^b f(x)dx \\end{equation} Consider the problem of determining the shaded area under the curve y = f(x) from x = a to x = b , as depicted in the figure below, and suppose that analytical integration is not feasible. Aside: How to embed a figure 1) Upload the file to the notebook directory, for this kind of environment use .png, .jpg 2) Use the markdown syntax ![](figure-filename). I used \"![figure1](panels.png)\" 3) The [] is a tag delimiter, I dont know how to use tags yet, its not a caption (bummer!) The function may be known in tabular form from experimental measurements or it may be known in an analytical form. The function is taken to be continuous within the interval a < x < b . We may divide the area into n vertical panels, each of width \\Delta x = (b - a)/n , and then add the areas of all strips to obtain A~\\approx \\int ydx . A representative panel of area A_i is shown with darker shading in the figure. Three useful numerical approximations are listed in the following sections. The approximations differ in how the function is represented by the panels --- in all cases the function is approximated by known polynomial models between the panel end points. In each case the greater the number of strips, and correspondingly smaller value of \\Delta x , the more accurate the approximation. Typically, one can begin with a relatively small number of panels and increase the number until the resulting area approximation stops changing.","title":"Background"},{"location":"solved-integration/NumericalIntegration/#rectangular-panels-in-primatives","text":"A primative is a structure built with the base python language and avoids packages, in my work it is obvious, the import package.name is absent in the source code. The figure below is a schematic of a rectangular panels. The figure is assuming the function structure is known and can be evaluated at an arbitrary location in the \\Delta x dimension. Each panel is treated as a rectangle, as shown by the representative panel whose height y_m is chosen visually so that the small cross-hatched areas are as nearly equal as possible. Thus, we form the sum \\sum y_m of the effective heights and multiply by \\Delta x . For a function known in analytical form, a value for y_m equal to that of the function at the midpoint x_i + \\Delta x /2 may be calculated and used in the summation. For tabulated functions, we have to choose to either take y_m as the value at the left endpoint or right endpoint. This limitation is often quite handy when we are trying to integrate a function that is integrable, but undefined on one endpoint. Lets try some examples in Python. Find the area under the curve y= x\\sqrt{1+x^2} from x = 0 to x = 2 . First lets read in the value for the lowerlimit, we will do some limited error checks to be sure user enters a number, but won't check that the number is non-negative. # RectangularPanels.py # Numerical Integration print (\"Program finds area under curve y = x * sqrt(1+x)\") # Get input data -- use error checking yes = 0 while yes == 0: x_low = input(\"Enter a lower bound x_low \\n\") try: x_low = float(x_low) yes = 1 except: print (\"x_low really needs to be a number, try again \\n\") # exit the while loop when finally have a valid number Program finds area under curve y = x * sqrt(1+x) Verify that value is indeed what we entered print(x_low) Now do the same for the upper limit, notice how we are using the yes variable. We set a \"fail\" value, and demand input until we get \"success\". The structure used here is called a try -- exception structure and is very common in programming. Error checking is really important so that garbled input does not hang things up. yes = 0 while yes == 0: x_high = input(\"Enter an upper bound x_high \\n\") try: x_high = float(x_high) yes = 1 except: print (\"x_high really needs to be a number, try again \\n\") # exit the while loop when finally have a valid number Again verify! print(x_high) Now use the try - exception structure to input how many panels we wish to use. Notice you can enter a negative value which will ultimately break things. Also observe this value is an integer. yes = 0 while yes == 0: how_many = input(\"Enter how many panels \\n\") try: how_many = int(how_many) yes = 1 except: print (\"Panels really needs to be a number, try again \\n\") # exit the while loop when finally have a valid number Again verify! print(how_many) Now we can actually perform the integration by evaluating the function at the panel half-widths. In this example we are using primitive arithmetic, so the \\sqrt{} is accomplished by exponentation, the syntax is c = a ** b is the operation c = a^b . The integration uses an accumulator, which is a memory location where subsquent results are added (accumulated) back into the accumulator. This structure is so common that there are alternate, compact syntax to perform this task, here it is all out in the open. The counting loop where we evaluate the function at different x values, starts at 1 and ends at how_many+1 because python for loops use an increment skip if equal structure. When the value in range equals how_many the for loop exits ( break is implied.) A loop control structure starting from 0 is shown in the code as a comment line. Simply uncomment this line, and comment the line just below to have the structure typical in python scripts. In the start from 1 case, we want to evaluate at the last value of how_many . # OK we should have the three things we need for evaluating the integral delta_x = (x_high - x_low)/float(how_many) # compute panel width xx = x_low + delta_x/2 # initial value for x ### OK THIS IS THE ACTUAL INTEGRATOR PART ### accumulated_area = 0.0 # initial value in an accumulator #for i in range(0,how_many,1): #note we are counting from 0 for i in range(1,how_many+1,1): #note we are counting from 1 accumulated_area = accumulated_area + ( xx * ( (1+xx**2)**(0.5) ) ) * delta_x xx = xx + delta_x ### AND WE ARE DONE INTEGRATING ############# Finally, we want to report our result print (\"Area under curve y = x * sqrt(1+x) from x = \",x_low,\\ \" to x = \",x_high,\"\\n is approximately: \",accumulated_area) # the backslash \\ # \" to x = ..... lets us use multiple lines # the \\n is a \"newline\" character The code implements rudimentary error checking -- it forces us to enter numeric values for the lower and upper values of x as well as the number of panels to use. It does not check for undefined ranges and such, but you should get the idea -- notice that a large fraction of the entire program is error trapping; this devotion to error trapping is typical for professional programs where you are going to distribute executable modules and not expect the end user to be a programmer.","title":"Rectangular Panels -- in primatives"},{"location":"solved-integration/NumericalIntegration/#using-the-math-package","text":"The actual computations are done rather crudely -- there is a math package that would give us the ability to compute the square root as a function call rather than exponentiation to a real values exponent. That is illustrated below # RectangularPanels.py # Numerical Integration # Use built-in math functions import math # a package of math functions # we are naming an object \"sqrt\" that will compute the square root def sqrt (x): return math.sqrt(x) # saves us having to type math.NAME every time we wish to use a function # in this program not all that meaningful, but in complex programs handy! print (\"Program finds area under curve y = x * sqrt(1+x)\") # Get input data -- use error checking yes = 0 while yes == 0: x_low = input(\"Enter a lower bound x_low \\n\") try: x_low = float(x_low) yes = 1 except: print (\"x_low really needs to be a number, try again \\n\") yes = 0 while yes == 0: x_high = input(\"Enter an upper bound x_high \\n\") try: x_high = float(x_high) yes = 1 except: print (\"x_high really needs to be a number, try again \\n\") yes = 0 while yes == 0: how_many = input(\"Enter how many panels \\n\") try: how_many = int(how_many) yes = 1 except: print (\"Panels really needs to be a number, try again \\n\") delta_x = (x_high - x_low)/float(how_many) # compute panel width accumulated_area = 0.0 # initial value in an accumulator xx = x_low + delta_x/2 # initial value for x for i in range(1,how_many+1,1): #note we are counting from 1 accumulated_area = accumulated_area + ( xx * sqrt(1+xx**2) ) * delta_x xx = xx + delta_x print (\"Area under curve y = x * sqrt(1+x) from x = \",x_low,\\ \" to x = \",x_high,\"\\n is approximately: \",accumulated_area)","title":"Using the math package"},{"location":"solved-integration/NumericalIntegration/#trapezoidal-panels","text":"The trapezoidal panels are approximated as shown in the figure below. The area A_i is the average height (y_i + y_{i+1} )/2 times \\Delta x . Adding the areas gives the area approximation as tabulated. For the example with the curvature shown, the approximation will be on the low side. For the reverse curvature, the approximation will be on the high side. The trapezoidal approximation is commonly used with tabulated values. The script below illustrates the trapezoidal method for approximating an integral. In the example, the left and right panel endpoints in x are set as separate variables x_{left} and x_{right} and incremented by \\Delta x as we step through the count-controlled repetition to accumulate the area. The corresponding y values are computed within the loop and averaged, then multiplied by \\Delta x and added to the accumulator. Finally the x values are incremented --- for grins, we used the += operator on the accumulator # TrapezoidalPanels.py # Numerical Integration # Use built-in math functions import math # a package of math functions # we are naming an object \"sqrt\" that will compute the square root def sqrt (x): return math.sqrt(x) # saves us having to type math.NAME every time we wish to use a function # in this program not all that meaningful, but in complex programs handy! print (\"Program finds area under curve y = x * sqrt(1+x)\") # Get input data -- use error checking yes = 0 while yes == 0: x_low = input(\"Enter a lower bound x_low \\n\") try: x_low = float(x_low) yes = 1 except: print (\"x_low really needs to be a number, try again \\n\") yes = 0 while yes == 0: x_high = input(\"Enter an upper bound x_high \\n\") try: x_high = float(x_high) yes = 1 except: print (\"x_high really needs to be a number, try again \\n\") yes = 0 while yes == 0: how_many = input(\"Enter how many panels \\n\") try: how_many = int(how_many) yes = 1 except: print (\"Panels really needs to be a number, try again \\n\") delta_x = (x_high - x_low)/float(how_many) # compute panel width accumulated_area = 0.0 # initial value in an accumulator x_left = x_low # initial value for x_left edge panel x_right = x_left + delta_x # initial value for x_right edge panel for i in range(1,how_many+1,1): #note we are counting from 1 y_left = ( x_left* sqrt(1+x_left**2) ) y_right = ( x_right* sqrt(1+x_right**2) ) accumulated_area += + (1./2.) * ( y_left + y_right ) * delta_x x_left += delta_x x_right += delta_x print (\"Area under curve y = x * sqrt(1+x) from x = \",x_low,\\ \" to x = \",x_high,\"\\n is approximately: \",accumulated_area)","title":"Trapezoidal Panels"},{"location":"solved-integration/NumericalIntegration/#parabolic-panels","text":"Parabolic panels approximate the shape of the panel with a parabola. The area between the chord and the curve (neglected in the trapezoidal solution) may be accounted for by approximating the function with a parabola passing through the points defined by three successive values of y . This area may be calculated from the geometry of the parabola and added to the trapezoidal area of the pair of strips to give the area \\Delta A of the pair as illustrated. Adding all of the \\Delta A s produces the tabulation shown, which is known as Simpson's rule. To use Simpson's rule, the number n of strips must be even. The same example as presented for rectangular panels is repeated, except using parabolic panels. The code is changed yet again because we will evaluate at each end of the panel as well as at an intermediate value. # ParabolicPanels.py # Numerical Integration # Use built-in math functions import math # a package of math functions # we are naming an object \"sqrt\" that will compute the square root def sqrt (x): return math.sqrt(x) # saves us having to type math.NAME every time we wish to use a function # in this program not all that meaningful, but in complex programs handy! print (\"Program finds area under curve y = x * sqrt(1+x)\") # Get input data -- use error checking yes = 0 while yes == 0: x_low = input(\"Enter a lower bound x_low \\n\") try: x_low = float(x_low) yes = 1 except: print (\"x_low really needs to be a number, try again \\n\") yes = 0 while yes == 0: x_high = input(\"Enter an upper bound x_high \\n\") try: x_high = float(x_high) yes = 1 except: print (\"x_high really needs to be a number, try again \\n\") yes = 0 while yes == 0: how_many = input(\"Enter how many panels \\n\") try: how_many = int(how_many) yes = 1 except: print (\"Panels really needs to be a number, try again \\n\") delta_x = (x_high - x_low)/float(how_many) # compute panel width accumulated_area = 0.0 # initial value in an accumulator x_left = x_low # initial value for x_left edge panel x_middle = x_left + delta_x # initial value for x_middle edge panel x_right = x_middle + delta_x # initial value for x_right edge panel how_many = int(how_many/2) # using 2 panels every step, so 1/2 many steps -- force integer result for i in range(1,how_many+1,1): #note we are counting from 1 y_left = ( x_left * sqrt(1+ x_left**2) ) y_middle = ( x_middle * sqrt(1+ x_middle**2) ) y_right = ( x_right * sqrt(1+ x_right**2) ) accumulated_area = accumulated_area + \\ (1./3.) * ( y_left + 4.* y_middle + y_right ) * delta_x x_left = x_left + 2*delta_x x_middle = x_left + delta_x x_right = x_middle + delta_x print (\"Area under curve y = x * sqrt(1+x) from x = \",x_low,\\ \" to x = \",x_high,\"\\n is approximately: \",accumulated_area) If we study all the forms of the numerical method we observe that the numerical integration method is really the sum of function values at specific locations in the interval of interest, with each value multiplied by a specific weight. In this development the weights were based on polynomials, but other method use different weighting functions. An extremely important method is called gaussian quadrature. This method is valuable because one can approximate convolution integrals quite effectively using quadrature routines, while the number of function evaluations for a polynomial based approximation could be hopeless. When the function values are tabular, we are going to have to accept the rectangular (with adaptations) and trapezoidal as our best tools to approximate an integral because we don't have any really effective way to evaluate the function between the tabulated values.","title":"Parabolic Panels"},{"location":"solved-integration/NumericalIntegrationTabular/","text":"Numerical Integration of Tabular Data This section is going to work with tabular data -- different from function evaluation, but similar. To be really useful, we need to learn how to read data from a file; manually entering tabular data is really time consuming, error prone, and just plain idiotic. So in this chapter we will learn how to read data from a file into a list, then we can process the list as if it were a function and integrate its contents. Reading from a file --- open, read, close files First, lets consider a file named MyFile.txt . The extension is important so that the Shell does not think it is a Python script. The contents of MyFile.txt are: 1 1 2 4 3 9 4 16 5 25 The code fragment below, will let us look at the file (already existing in our local directory) import subprocess # lets us run \"shell\" commands and recover stdio stream usefull_cat_call = subprocess.run([\"cat\",\"MyFile.txt\"], stdout=subprocess.PIPE, text=True) # this is the call to run the bash command \"cat MyFile.txt\" which will display the contents of the file if it exists. print(usefull_cat_call.stdout) 1 1 2 4 3 9 4 16 5 25 Now that we know that the file exists,to read the contents into a Python script we have to do the following: Open a connection to the file --- this is a concept common to all languages, it might be called something different, but the program needs to somehow know the location and name of the file. Read the contents into an object --- we have a lot of control on how this gets done, for the time being we won't exercise much control yet. When you do substantial programs, you will depend on the control of the reads (and writes). Disconnect the file --- this too is common to all languages. Its a really easy step to forget. Not a big deal if the program ends as planned but terrible if there is a error in the program and the connection is still open. Usually nothing bad happens, but with an open connection it is possible for the file to get damaged. If that file represents millions of customers credit card numbers, that's kind of a problem, and time to go work on your resume, or get your passport collection out and choose a country without extradition. The code fragment below performs these three tasks and prints the things we read Afile = open(\"MyFile.txt\",\"r\") # open a connection to the file; set to \"read\" # read the five lines line1 = Afile.readline() line2 = Afile.readline() line3 = Afile.readline() line4 = Afile.readline() line5 = Afile.readline() Afile.close() # disconnect from the file # echo the input print(line1,end=\"\") print(line2,end=\"\") print(line3,end=\"\") print(line4,end=\"\") print(line5,end=\"\") 1 1 2 4 3 9 4 16 5 25 Read into a list A far more useful and elegant way to read from a file is to use a for loop. The attribute line within a file is an iterable, hence construction the loop is pretty straightforward. A script fragment below does the same thing as the example above, but uses a for loop to accomplish stepping through the file. Additionally, I have added a counter to keep track of how many lines were read --- in a lot of engineering programs, the number of things read becomes important later in a program, hence it is usually a good idea to capture the count when the data are first read. First lets work out if we can automatically detect the end of the file. So this script just reads and prints the attribute line from object Afile . Notice how the print statement is changed, to suppress the extra line feed. Afile = open(\"MyFile.txt\",\"r\") # open a connection to the file; set to \"read\" # read using a for loop, exit when at end of file and report line count how_many_lines = 0 # start our counter! for line in Afile: print(line,end=\"\") how_many_lines += 1 Afile.close() # disconnect from the file print(\"\\nFile has \",how_many_lines,\" records (lines)\") 1 1 2 4 3 9 4 16 5 25 File has 5 records (lines) Now we will add a list to receive the input, here it reads the file above as a string into a list xy , then splits that list and places the contents into two other lists, x and y . The script has several parts to discuss. First, the destination variables (lists) must be created -- I used the null list concept here because I don't know how big the list is until I read the list. Next I used the .append() method which operates on the xy list. The arguments of the method [str(n) for n in line.strip().split()] tells the program that the elements are to be interpreted as a string, and to split (split) the line into sub-strings based on a null delimiter (whitespace), and to remove all the whitespace (strip) characters. Once the line is split, the strings are appended into the xy list. The xy list is printed to show that it is a list of 5 things, each thing being a string comprised of two sets of characters separated by a comma. xy is a list of strings. The next section of the code then uses the pair function within another .append() method to break the character sets in each element of xy into two parts x and y . Lastly during the pair operation, the code also converts the data into real values (float) and then prints the data in two columns. This seems like a lot of work, but we could easily get this code to be super reliable, then save it as a function and never have to write it again. That too comes later -- suffice to say for now we can read a file, parse its contents into two lists x and y . Thus we are now able to integrate tabular data. xy = [] # null list to store the lines x = [] # a null list for the first column y = [] # a null list for the second column Afile = open(\"MyFile.txt\",\"r\") # open a connection to the file; set to \"read\" # read using a for loop, exit when at end of file and report line count how_many_lines = 0 # start our counter! for line in Afile: print(line,end=\"\") xy.append([str(n) for n in line.strip().split()]) # append line to xy, split the line on whitespace, strip out whitespace how_many_lines += 1 Afile.close() # disconnect from the file print(\"\\nFile has \",how_many_lines,\" records (lines)\") print(\"The list is: \",end=\"\") print(xy) # the list for pair in xy: # parse into x and y x.append(float(pair[0])) y.append(float(pair[1])) # verify parsed for i in range (0,how_many_lines,1): print(\"x = \",x[i],\" y = \",y[i]) 1 1 2 4 3 9 4 16 5 25 File has 5 records (lines) The list is: [['1', '1'], ['2', '4'], ['3', '9'], ['4', '16'], ['5', '25']] x = 1.0 y = 1.0 x = 2.0 y = 4.0 x = 3.0 y = 9.0 x = 4.0 y = 16.0 x = 5.0 y = 25.0 Integrating the Tabular Data Suppose instead of a function we only have tabulations and wist to estimate the area under the curve represented by the tabular values. Then our integration rules from the prior chapter still work more or less, except the rectangular panels will have to be shifted to either the left edge or right edge of a panel (where the tabulation exists). Lets just examine an example. Suppose some measurement technology produced a table of related values. The excitation variable is x and f(x) is the response. x f(x) 1.0 1.543 1.1 1.668 1.2 1.811 1.3 1.971 1.4 2.151 1.5 2.352 1.6 2.577 1.7 2.828 1.8 3.107 To integrate this table using the trapezoidal method is straightforward. We will modify our earlier code to read the table (which we put into a file), and compute the integral. # My Tabular Integration # Integrate a table of values using Trapezoidal Panels xy = [] # null list to store the lines x = [] # a null list for the first column y = [] # a null list for the second column Afile = open(\"MyTableOfData.txt\",\"r\") # open a connection to the file; set to \"read\" # read using a for loop, exit when at end of file and report line count how_many_lines = 0 # start our counter! for line in Afile: print(line,end=\"\") xy.append([str(n) for n in line.strip().split()]) # append line to xy, split the line on whitespace, strip out whitespace how_many_lines += 1 Afile.close() # disconnect from the file print(\"\\nFile has \",how_many_lines,\" records (lines)\") print(\"The list is: \",end=\"\") print(xy) # the list for pair in xy: # parse into x and y x.append(float(pair[0])) y.append(float(pair[1])) # verify parsed for i in range (0,how_many_lines,1): print(\"x = \",x[i],\" y = \",y[i]) # now the actual integration accumulated_area = 0 # an accumulator for i in range(0,how_many_lines-1,1): #index stops at n-1 things because each panel evaluated at both ends delta_x = x[i+1]-x[i] height =(y[i+1]+y[i])/2.0 accumulated_area += height*delta_x print(\"Area = \",accumulated_area) # report the result 1.0 1.543 1.1 1.668 1.2 1.811 1.3 1.971 1.4 2.151 1.5 2.352 1.6 2.577 1.7 2.828 1.8 3.107 File has 9 records (lines) The list is: [['1.0', '1.543'], ['1.1', '1.668'], ['1.2', '1.811'], ['1.3', '1.971'], ['1.4', '2.151'], ['1.5', '2.352'], ['1.6', '2.577'], ['1.7', '2.828'], ['1.8', '3.107']] x = 1.0 y = 1.543 x = 1.1 y = 1.668 x = 1.2 y = 1.811 x = 1.3 y = 1.971 x = 1.4 y = 2.151 x = 1.5 y = 2.352 x = 1.6 y = 2.577 x = 1.7 y = 2.828 x = 1.8 y = 3.107 Area = 1.7683000000000002 Cool, it seems to work -- now tidy the code a bit by suppressing extra outputs # My Tabular Integration # Integrate a table of values using Trapezoidal Panels xy = [] # null list to store the lines x = [] # a null list for the first column y = [] # a null list for the second column Afile = open(\"MyTableOfData.txt\",\"r\") # open a connection to the file; set to \"read\" # read using a for loop, exit when at end of file and report line count how_many_lines = 0 # start our counter! for line in Afile: ##print(line,end=\"\") xy.append([str(n) for n in line.strip().split()]) # append line to xy, split the line on whitespace, strip out whitespace how_many_lines += 1 Afile.close() # disconnect from the file print(\"\\nRecords read =: \",how_many_lines) ##print(\"The list is: \",end=\"\") ##print(xy) # the list for pair in xy: # parse into x and y x.append(float(pair[0])) y.append(float(pair[1])) # verify parsed for i in range (0,how_many_lines,1): print(\"x = \",x[i],\" y = \",y[i]) # now the actual integration accumulated_area = 0 # an accumulator for i in range(0,how_many_lines-1,1): #index stops at n-1 things because each panel evaluated at both ends delta_x = x[i+1]-x[i] height =(y[i+1]+y[i])/2.0 accumulated_area += height*delta_x print(\"Area = \",accumulated_area) # report the result Records read =: 9 x = 1.0 y = 1.543 x = 1.1 y = 1.668 x = 1.2 y = 1.811 x = 1.3 y = 1.971 x = 1.4 y = 2.151 x = 1.5 y = 2.352 x = 1.6 y = 2.577 x = 1.7 y = 2.828 x = 1.8 y = 3.107 Area = 1.7683000000000002 Realistically the only other simple integration method for tabular data is the rectangular rule, either using the left edge of a panel or the right edge of a panel (and I suppose you could do both and average the result which would be the trapezoidal method).","title":"Numerical Integration of Tabular Data"},{"location":"solved-integration/NumericalIntegrationTabular/#numerical-integration-of-tabular-data","text":"This section is going to work with tabular data -- different from function evaluation, but similar. To be really useful, we need to learn how to read data from a file; manually entering tabular data is really time consuming, error prone, and just plain idiotic. So in this chapter we will learn how to read data from a file into a list, then we can process the list as if it were a function and integrate its contents.","title":"Numerical Integration of Tabular Data"},{"location":"solved-integration/NumericalIntegrationTabular/#reading-from-a-file-open-read-close-files","text":"First, lets consider a file named MyFile.txt . The extension is important so that the Shell does not think it is a Python script. The contents of MyFile.txt are: 1 1 2 4 3 9 4 16 5 25 The code fragment below, will let us look at the file (already existing in our local directory) import subprocess # lets us run \"shell\" commands and recover stdio stream usefull_cat_call = subprocess.run([\"cat\",\"MyFile.txt\"], stdout=subprocess.PIPE, text=True) # this is the call to run the bash command \"cat MyFile.txt\" which will display the contents of the file if it exists. print(usefull_cat_call.stdout) 1 1 2 4 3 9 4 16 5 25 Now that we know that the file exists,to read the contents into a Python script we have to do the following: Open a connection to the file --- this is a concept common to all languages, it might be called something different, but the program needs to somehow know the location and name of the file. Read the contents into an object --- we have a lot of control on how this gets done, for the time being we won't exercise much control yet. When you do substantial programs, you will depend on the control of the reads (and writes). Disconnect the file --- this too is common to all languages. Its a really easy step to forget. Not a big deal if the program ends as planned but terrible if there is a error in the program and the connection is still open. Usually nothing bad happens, but with an open connection it is possible for the file to get damaged. If that file represents millions of customers credit card numbers, that's kind of a problem, and time to go work on your resume, or get your passport collection out and choose a country without extradition. The code fragment below performs these three tasks and prints the things we read Afile = open(\"MyFile.txt\",\"r\") # open a connection to the file; set to \"read\" # read the five lines line1 = Afile.readline() line2 = Afile.readline() line3 = Afile.readline() line4 = Afile.readline() line5 = Afile.readline() Afile.close() # disconnect from the file # echo the input print(line1,end=\"\") print(line2,end=\"\") print(line3,end=\"\") print(line4,end=\"\") print(line5,end=\"\") 1 1 2 4 3 9 4 16 5 25","title":"Reading from a file --- open, read, close files"},{"location":"solved-integration/NumericalIntegrationTabular/#read-into-a-list","text":"A far more useful and elegant way to read from a file is to use a for loop. The attribute line within a file is an iterable, hence construction the loop is pretty straightforward. A script fragment below does the same thing as the example above, but uses a for loop to accomplish stepping through the file. Additionally, I have added a counter to keep track of how many lines were read --- in a lot of engineering programs, the number of things read becomes important later in a program, hence it is usually a good idea to capture the count when the data are first read. First lets work out if we can automatically detect the end of the file. So this script just reads and prints the attribute line from object Afile . Notice how the print statement is changed, to suppress the extra line feed. Afile = open(\"MyFile.txt\",\"r\") # open a connection to the file; set to \"read\" # read using a for loop, exit when at end of file and report line count how_many_lines = 0 # start our counter! for line in Afile: print(line,end=\"\") how_many_lines += 1 Afile.close() # disconnect from the file print(\"\\nFile has \",how_many_lines,\" records (lines)\") 1 1 2 4 3 9 4 16 5 25 File has 5 records (lines) Now we will add a list to receive the input, here it reads the file above as a string into a list xy , then splits that list and places the contents into two other lists, x and y . The script has several parts to discuss. First, the destination variables (lists) must be created -- I used the null list concept here because I don't know how big the list is until I read the list. Next I used the .append() method which operates on the xy list. The arguments of the method [str(n) for n in line.strip().split()] tells the program that the elements are to be interpreted as a string, and to split (split) the line into sub-strings based on a null delimiter (whitespace), and to remove all the whitespace (strip) characters. Once the line is split, the strings are appended into the xy list. The xy list is printed to show that it is a list of 5 things, each thing being a string comprised of two sets of characters separated by a comma. xy is a list of strings. The next section of the code then uses the pair function within another .append() method to break the character sets in each element of xy into two parts x and y . Lastly during the pair operation, the code also converts the data into real values (float) and then prints the data in two columns. This seems like a lot of work, but we could easily get this code to be super reliable, then save it as a function and never have to write it again. That too comes later -- suffice to say for now we can read a file, parse its contents into two lists x and y . Thus we are now able to integrate tabular data. xy = [] # null list to store the lines x = [] # a null list for the first column y = [] # a null list for the second column Afile = open(\"MyFile.txt\",\"r\") # open a connection to the file; set to \"read\" # read using a for loop, exit when at end of file and report line count how_many_lines = 0 # start our counter! for line in Afile: print(line,end=\"\") xy.append([str(n) for n in line.strip().split()]) # append line to xy, split the line on whitespace, strip out whitespace how_many_lines += 1 Afile.close() # disconnect from the file print(\"\\nFile has \",how_many_lines,\" records (lines)\") print(\"The list is: \",end=\"\") print(xy) # the list for pair in xy: # parse into x and y x.append(float(pair[0])) y.append(float(pair[1])) # verify parsed for i in range (0,how_many_lines,1): print(\"x = \",x[i],\" y = \",y[i]) 1 1 2 4 3 9 4 16 5 25 File has 5 records (lines) The list is: [['1', '1'], ['2', '4'], ['3', '9'], ['4', '16'], ['5', '25']] x = 1.0 y = 1.0 x = 2.0 y = 4.0 x = 3.0 y = 9.0 x = 4.0 y = 16.0 x = 5.0 y = 25.0","title":"Read into a list"},{"location":"solved-integration/NumericalIntegrationTabular/#integrating-the-tabular-data","text":"Suppose instead of a function we only have tabulations and wist to estimate the area under the curve represented by the tabular values. Then our integration rules from the prior chapter still work more or less, except the rectangular panels will have to be shifted to either the left edge or right edge of a panel (where the tabulation exists). Lets just examine an example. Suppose some measurement technology produced a table of related values. The excitation variable is x and f(x) is the response. x f(x) 1.0 1.543 1.1 1.668 1.2 1.811 1.3 1.971 1.4 2.151 1.5 2.352 1.6 2.577 1.7 2.828 1.8 3.107 To integrate this table using the trapezoidal method is straightforward. We will modify our earlier code to read the table (which we put into a file), and compute the integral. # My Tabular Integration # Integrate a table of values using Trapezoidal Panels xy = [] # null list to store the lines x = [] # a null list for the first column y = [] # a null list for the second column Afile = open(\"MyTableOfData.txt\",\"r\") # open a connection to the file; set to \"read\" # read using a for loop, exit when at end of file and report line count how_many_lines = 0 # start our counter! for line in Afile: print(line,end=\"\") xy.append([str(n) for n in line.strip().split()]) # append line to xy, split the line on whitespace, strip out whitespace how_many_lines += 1 Afile.close() # disconnect from the file print(\"\\nFile has \",how_many_lines,\" records (lines)\") print(\"The list is: \",end=\"\") print(xy) # the list for pair in xy: # parse into x and y x.append(float(pair[0])) y.append(float(pair[1])) # verify parsed for i in range (0,how_many_lines,1): print(\"x = \",x[i],\" y = \",y[i]) # now the actual integration accumulated_area = 0 # an accumulator for i in range(0,how_many_lines-1,1): #index stops at n-1 things because each panel evaluated at both ends delta_x = x[i+1]-x[i] height =(y[i+1]+y[i])/2.0 accumulated_area += height*delta_x print(\"Area = \",accumulated_area) # report the result 1.0 1.543 1.1 1.668 1.2 1.811 1.3 1.971 1.4 2.151 1.5 2.352 1.6 2.577 1.7 2.828 1.8 3.107 File has 9 records (lines) The list is: [['1.0', '1.543'], ['1.1', '1.668'], ['1.2', '1.811'], ['1.3', '1.971'], ['1.4', '2.151'], ['1.5', '2.352'], ['1.6', '2.577'], ['1.7', '2.828'], ['1.8', '3.107']] x = 1.0 y = 1.543 x = 1.1 y = 1.668 x = 1.2 y = 1.811 x = 1.3 y = 1.971 x = 1.4 y = 2.151 x = 1.5 y = 2.352 x = 1.6 y = 2.577 x = 1.7 y = 2.828 x = 1.8 y = 3.107 Area = 1.7683000000000002 Cool, it seems to work -- now tidy the code a bit by suppressing extra outputs # My Tabular Integration # Integrate a table of values using Trapezoidal Panels xy = [] # null list to store the lines x = [] # a null list for the first column y = [] # a null list for the second column Afile = open(\"MyTableOfData.txt\",\"r\") # open a connection to the file; set to \"read\" # read using a for loop, exit when at end of file and report line count how_many_lines = 0 # start our counter! for line in Afile: ##print(line,end=\"\") xy.append([str(n) for n in line.strip().split()]) # append line to xy, split the line on whitespace, strip out whitespace how_many_lines += 1 Afile.close() # disconnect from the file print(\"\\nRecords read =: \",how_many_lines) ##print(\"The list is: \",end=\"\") ##print(xy) # the list for pair in xy: # parse into x and y x.append(float(pair[0])) y.append(float(pair[1])) # verify parsed for i in range (0,how_many_lines,1): print(\"x = \",x[i],\" y = \",y[i]) # now the actual integration accumulated_area = 0 # an accumulator for i in range(0,how_many_lines-1,1): #index stops at n-1 things because each panel evaluated at both ends delta_x = x[i+1]-x[i] height =(y[i+1]+y[i])/2.0 accumulated_area += height*delta_x print(\"Area = \",accumulated_area) # report the result Records read =: 9 x = 1.0 y = 1.543 x = 1.1 y = 1.668 x = 1.2 y = 1.811 x = 1.3 y = 1.971 x = 1.4 y = 2.151 x = 1.5 y = 2.352 x = 1.6 y = 2.577 x = 1.7 y = 2.828 x = 1.8 y = 3.107 Area = 1.7683000000000002 Realistically the only other simple integration method for tabular data is the rectangular rule, either using the left edge of a panel or the right edge of a panel (and I suppose you could do both and average the result which would be the trapezoidal method).","title":"Integrating the Tabular Data"},{"location":"solved-newton/NewtonsMethod/","text":"Single Variable Newtons Method The application of fundamental principles of modeling and mechanics often leads to an algebraic or transcendental equation that cannot be easily solved and represented in a closed form. In these cases a numerical method is required to obtain an estimate of the root or roots of the expression. Newton's method is an iterative technique that can produce good estimates of solutions to such equations. The method is employed by rewriting the equation in the form f(x) = 0 , then successively manipulating guesses for x until the function evaluates to a value close enough to zero for the modeler to accept. The figure above is a graph of some function whose intercept with the x-axis is unknown. The goal of Newton's method is to find this intersection (root) from a realistic first guess. Suppose the first guess is x1 , shown on the figure as the right-most specific value of x . The value of the function at this location is f(x1) . Because x1 is supposed to be a root the difference from the value zero represents an error in the estimate. Newton's method simply provides a recipe for corrections to this error. Provided x1 is not near a minimum or maximum (slope of the function is not zero) then a better estimate of the root can be obtained by extending a tangent line from x1, f(x1) to the x-axis . The intersection of this line with the axis represents a better estimate of the root. This new estimate is x2 . A formula for x2 can be derived from the geometry of the triangle x2,f(x1),x1 . Recall from calculus that the tangent to a function at a particular point is the first derivative of the function. Therefore, from the geometry of the triangle and the definition of tangent we can write, \\begin{equation} tan(\\theta)=\\frac{df}{dx}\\Biggr\\vert_{x_1} = \\frac{f(x_1)}{x_1 - x_2} \\end{equation} Solving the equation for x 2 results in a formula that expresses x2 in terms of the first guess plus a correction term. \\begin{equation} x_2=x_1 - \\frac{f(x_1)}{\\frac{df}{dx}\\vert_{x_1}} \\end{equation} The second term on the right hand side is the correction term to the estimate on the right hand side. Once x2 is calculated we can repeat the formula substituting x2 for x1 and x3 for x2 in the formula. Repeated application usually leads to one of three outcomes: 1. a root; 2. divergence to +/- \\inf ; or 3. cycling. These three outcomes are discussed below in various subsections along with some remedies. The generalized formula is \\begin{equation} x_{k+1}=x_{k} - \\frac{ f(x_{k}) }{ \\frac{df}{dx}\\rvert_{x_k} } \\label{eqn:NewtonFormula} \\end{equation} If the derivative is evaluated using analytical derivatives the method is called Newton's method, if approximations to the derivative are used, it is called a quasi-Newton method. Newton's Method: Using analytical derivative computation This subsection is an example in Python of implementing Newton's method with analytical derivatives. The recipe itself is: Write the function in proper form, and code it into a computer. Write the derivative in proper form and code it into a computer. Make an initial guess of the solution (0 and 1 are always convenient guesses). Evaluate the function, evaluate the derivative, calculate their ratio. Subtract the ratio from the current guess and save the result as the update. Test for stopping: Did the update stay the same value? Yes, then stop, probably have a solution. Is the function nearly zero? Yes, then stop we probably have a solution. Have we tried too many updates? Yes, then stop the process is probably cycling, stop. If stopping is indicated proceed to next step, otherwise proceed back to step 4. Stopping indicated, report last update as the result (or report failure to find solution), and related information about the status of the numerical method. The following example illustrates these step as well as an ipython implementation of Newton's method. Suppose we wish to find a root (value of x ) that satisfies: \\begin{equation} f(x) = e^x - 10 cos(x) -100 \\end{equation} Then we will need to code it into a script. Here is a code fragment that will generate the prototype function # import built in function for e^x, cosine from math import exp, cos, sin # Define the function def func(x): func = exp(x) - 10*cos(x) - 100 #using the name as the temp var return func Notice in the code fragment we import three built-in functions from the Python math package, specifically \\exp() , \\sin() , and \\cos () . The next step is to code the derivative. In this case the derivative is \\begin{equation} \\frac{df}{dx}\\vert{(x)} = e^x + 10 \\sin(x) \\end{equation} and the prototype function is coded as def dfdx(x): dfdx = exp(x) + 10*sin(x) return dfdx Next we will need script to read in an initial guess, and ask us how many trials we will use to try to find a solution, as well as how close to zero we should be before we declare victory. # Now for the Newton Method Implementation # Get initial guess, use a simple error trap yes=0 while yes == 0: xnow = input(\"Enter an initial guess for Newton method \\n\") try: xnow = float(xnow) yes =1 except: print (\"Value should be numeric, try again \\n\") # Get number trials, use a simple error trap yes=0 while yes == 0: HowMany = input(\"Enter iteration maximum \\n\") try: HowMany = int(HowMany) yes =1 except: print (\"Value should be numeric, try again \\n\") # Get stopping criterion yes=0 while yes == 0: HowSmall = input(\"Enter a solution tolerance (e.g. 1e-06) \\n\") try: HowSmall= float(HowSmall) yes =1 except: print (\"Value should be numeric, try again \\n\") Enter an initial guess for Newton method 1 Enter iteration maximum 3 Enter a solution tolerance (e.g. 1e-06) 1e-6 The use of HowSmall is called a zero tolerance. We will use the same numerical value for two tolerance tests. Also notice how we are using error traps to force numeric input. Probably overkill for this example, but we already wrote the code in an earlier essay, so might as well reuse the code. Professional codes do a lot of error checking before launching into the actual processing - especially if the processing part is time consuming, its worth the time to check for obvious errors before running for a few hours then at some point failing because of an input value error that was predictable. Now back to the tolerance tests. The first test is to determine if the update has changed or not. If it has not, we may not have a correct answer, but there is no point continuing because the update is unlikely to move further. The test is something like \\begin{equation} \\text{IF}~\\lvert x_{k+1} - x_{k} \\rvert < \\text{Tol.~ THEN Exit and Report Results} \\end{equation} The second test is if the function value is close to zero. The structure of the test is similar, just an different argument. The second test is something like \\begin{equation} \\text{IF}~\\lvert f(x_{k+1}) \\rvert < \\text{Tol.~ THEN Exit and Report Results} \\end{equation} One can see from the nature of the two tests that a programmer might want to make the tolerance values different. This modification is left as a reader exercise. Checking for maximum iterations is relatively easy, we just include code that checks for normal exit the loop. Here is code fragment that implements the method, makes the various tests, and reports results. # now we begin the process count = 0 for i in range(0,HowMany,1): xnew = xnow - func(xnow)/dfdx(xnow) # stopping criteria -- update not changing if abs(xnew - xnow) < HowSmall: print (\"Update not changing \\n\") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) break else: xnow = xnew count = count +1 continue # stopping criteria -- function close to zero if abs( func(xnew) ) < HowSmall: print (\"Function value close to zero \\n\") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) break else: xnow = xnew count = count +1 continue # next step, then have either broken from the loop or iteration counted out if count == HowMany: print(\" Iteration Limit Reached \") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) print(\"End of NewtonMethod.py \") Iteration Limit Reached Function value = 3676.8081814664183 Root value = 8.235647852860856 End of NewtonMethod.py Now we simply connect the three fragments, and we would have a working Python script that implements Newton's method for the example equation. The example is specific to the particular function provided, but the programmer could move the two functions func and dfdx into a user specified module, and then load that module in the program to make it even more generic. The next section will use such an approach to illustrate the ability to build a generalized Newton method and only have to program the function itself Newton's Method : Finite-difference to derivative estimate A practical difficulty in using Newton's method is determining the value of the derivative in cases where differentiation is difficult. In these cases we can replace the derivative by a finite difference equation and then proceed as in Newton's method. Recall from calculus that the derivative was defined as the limit of the difference quotient: \\begin{equation} \\frac{df}{dx}\\vert_{x} = \\lim_{\\Delta x \\rightarrow 0}\\frac{f(x + \\Delta x) - f(x) }{\\Delta x} \\end{equation} A good approximation to the derivative should be possible by using this formula with a small, but non-zero value for \\Delta x . \\begin{equation} \\frac{df}{dx}\\vert_{x} \\approx \\frac{f(x + \\Delta x) - f(x) }{\\Delta x} \\end{equation} When one replaces the derivative with the difference formula the root finding method the resulting update formula is \\begin{equation} x_{k+1}=x_k - \\frac{f(x_k) \\Delta x}{f(x_k + \\Delta x)-f(x_k)} \\end{equation} This root-finding method is called a quasi-Newton method. Here is the code fragment that we change by commenting out the analytical derivative and replacing it with a first-order finite difference approximation of the derivative. The numerical value 1e-06 is called the step size ( \\Delta x ) and should be an input value (rather than built-in to the code as shown here) like the tolerance test values, and be passed to the function as another argument. # reset the notebook %reset Once deleted, variables cannot be recovered. Proceed (y/[n])? y # import built in function for e^x, cosine from math import exp, cos, sin # Define the function def func(x): func = exp(x) - 10*cos(x) - 100 #using the name as the temp var return func def dfdx(x): # dfdx = exp(x) + 10*sin(x) dfdx = (func(x + 1e-06) - func(x) )/ (1e-06) return (dfdx) # Now for the Newton Method Implementation # Get initial guess, use a simple error trap yes=0 while yes == 0: xnow = input(\"Enter an initial guess for Newton method \\n\") try: xnow = float(xnow) yes =1 except: print (\"Value should be numeric, try again \\n\") # Get number trials, use a simple error trap yes=0 while yes == 0: HowMany = input(\"Enter iteration maximum \\n\") try: HowMany = int(HowMany) yes =1 except: print (\"Value should be numeric, try again \\n\") # Get stopping criterion yes=0 while yes == 0: HowSmall = input(\"Enter a solution tolerance (e.g. 1e-06) \\n\") try: HowSmall= float(HowSmall) yes =1 except: print (\"Value should be numeric, try again \\n\") Enter an initial guess for Newton method 2 Enter iteration maximum 33 Enter a solution tolerance (e.g. 1e-06) 1e-9 # now we begin the process count = 0 for i in range(0,HowMany,1): xnew = xnow - func(xnow)/dfdx(xnow) # stopping criteria -- update not changing if abs(xnew - xnow) < HowSmall: print (\"Update not changing \\n\") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) break else: xnow = xnew count = count +1 continue # stopping criteria -- function close to zero if abs( func(xnew) ) < HowSmall: print (\"Function value close to zero \\n\") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) break else: xnow = xnew count = count +1 continue # next step, then have either broken from the loop or iteration counted out if count == HowMany: print(\" Iteration Limit Reached \") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) print(\"End of NewtonMethod.py \") Update not changing Function value = 1.4210854715202004e-14 Root value = 4.593209147284144 End of NewtonMethod.py Pretty much the same result, but now we dont have to determine the analytical derivative.","title":"Single Variable Newtons Method"},{"location":"solved-newton/NewtonsMethod/#single-variable-newtons-method","text":"The application of fundamental principles of modeling and mechanics often leads to an algebraic or transcendental equation that cannot be easily solved and represented in a closed form. In these cases a numerical method is required to obtain an estimate of the root or roots of the expression. Newton's method is an iterative technique that can produce good estimates of solutions to such equations. The method is employed by rewriting the equation in the form f(x) = 0 , then successively manipulating guesses for x until the function evaluates to a value close enough to zero for the modeler to accept. The figure above is a graph of some function whose intercept with the x-axis is unknown. The goal of Newton's method is to find this intersection (root) from a realistic first guess. Suppose the first guess is x1 , shown on the figure as the right-most specific value of x . The value of the function at this location is f(x1) . Because x1 is supposed to be a root the difference from the value zero represents an error in the estimate. Newton's method simply provides a recipe for corrections to this error. Provided x1 is not near a minimum or maximum (slope of the function is not zero) then a better estimate of the root can be obtained by extending a tangent line from x1, f(x1) to the x-axis . The intersection of this line with the axis represents a better estimate of the root. This new estimate is x2 . A formula for x2 can be derived from the geometry of the triangle x2,f(x1),x1 . Recall from calculus that the tangent to a function at a particular point is the first derivative of the function. Therefore, from the geometry of the triangle and the definition of tangent we can write, \\begin{equation} tan(\\theta)=\\frac{df}{dx}\\Biggr\\vert_{x_1} = \\frac{f(x_1)}{x_1 - x_2} \\end{equation} Solving the equation for x 2 results in a formula that expresses x2 in terms of the first guess plus a correction term. \\begin{equation} x_2=x_1 - \\frac{f(x_1)}{\\frac{df}{dx}\\vert_{x_1}} \\end{equation} The second term on the right hand side is the correction term to the estimate on the right hand side. Once x2 is calculated we can repeat the formula substituting x2 for x1 and x3 for x2 in the formula. Repeated application usually leads to one of three outcomes: 1. a root; 2. divergence to +/- \\inf ; or 3. cycling. These three outcomes are discussed below in various subsections along with some remedies. The generalized formula is \\begin{equation} x_{k+1}=x_{k} - \\frac{ f(x_{k}) }{ \\frac{df}{dx}\\rvert_{x_k} } \\label{eqn:NewtonFormula} \\end{equation} If the derivative is evaluated using analytical derivatives the method is called Newton's method, if approximations to the derivative are used, it is called a quasi-Newton method.","title":"Single Variable Newtons Method"},{"location":"solved-newton/NewtonsMethod/#newtons-method-using-analytical-derivative-computation","text":"This subsection is an example in Python of implementing Newton's method with analytical derivatives. The recipe itself is: Write the function in proper form, and code it into a computer. Write the derivative in proper form and code it into a computer. Make an initial guess of the solution (0 and 1 are always convenient guesses). Evaluate the function, evaluate the derivative, calculate their ratio. Subtract the ratio from the current guess and save the result as the update. Test for stopping: Did the update stay the same value? Yes, then stop, probably have a solution. Is the function nearly zero? Yes, then stop we probably have a solution. Have we tried too many updates? Yes, then stop the process is probably cycling, stop. If stopping is indicated proceed to next step, otherwise proceed back to step 4. Stopping indicated, report last update as the result (or report failure to find solution), and related information about the status of the numerical method. The following example illustrates these step as well as an ipython implementation of Newton's method. Suppose we wish to find a root (value of x ) that satisfies: \\begin{equation} f(x) = e^x - 10 cos(x) -100 \\end{equation} Then we will need to code it into a script. Here is a code fragment that will generate the prototype function # import built in function for e^x, cosine from math import exp, cos, sin # Define the function def func(x): func = exp(x) - 10*cos(x) - 100 #using the name as the temp var return func Notice in the code fragment we import three built-in functions from the Python math package, specifically \\exp() , \\sin() , and \\cos () . The next step is to code the derivative. In this case the derivative is \\begin{equation} \\frac{df}{dx}\\vert{(x)} = e^x + 10 \\sin(x) \\end{equation} and the prototype function is coded as def dfdx(x): dfdx = exp(x) + 10*sin(x) return dfdx Next we will need script to read in an initial guess, and ask us how many trials we will use to try to find a solution, as well as how close to zero we should be before we declare victory. # Now for the Newton Method Implementation # Get initial guess, use a simple error trap yes=0 while yes == 0: xnow = input(\"Enter an initial guess for Newton method \\n\") try: xnow = float(xnow) yes =1 except: print (\"Value should be numeric, try again \\n\") # Get number trials, use a simple error trap yes=0 while yes == 0: HowMany = input(\"Enter iteration maximum \\n\") try: HowMany = int(HowMany) yes =1 except: print (\"Value should be numeric, try again \\n\") # Get stopping criterion yes=0 while yes == 0: HowSmall = input(\"Enter a solution tolerance (e.g. 1e-06) \\n\") try: HowSmall= float(HowSmall) yes =1 except: print (\"Value should be numeric, try again \\n\") Enter an initial guess for Newton method 1 Enter iteration maximum 3 Enter a solution tolerance (e.g. 1e-06) 1e-6 The use of HowSmall is called a zero tolerance. We will use the same numerical value for two tolerance tests. Also notice how we are using error traps to force numeric input. Probably overkill for this example, but we already wrote the code in an earlier essay, so might as well reuse the code. Professional codes do a lot of error checking before launching into the actual processing - especially if the processing part is time consuming, its worth the time to check for obvious errors before running for a few hours then at some point failing because of an input value error that was predictable. Now back to the tolerance tests. The first test is to determine if the update has changed or not. If it has not, we may not have a correct answer, but there is no point continuing because the update is unlikely to move further. The test is something like \\begin{equation} \\text{IF}~\\lvert x_{k+1} - x_{k} \\rvert < \\text{Tol.~ THEN Exit and Report Results} \\end{equation} The second test is if the function value is close to zero. The structure of the test is similar, just an different argument. The second test is something like \\begin{equation} \\text{IF}~\\lvert f(x_{k+1}) \\rvert < \\text{Tol.~ THEN Exit and Report Results} \\end{equation} One can see from the nature of the two tests that a programmer might want to make the tolerance values different. This modification is left as a reader exercise. Checking for maximum iterations is relatively easy, we just include code that checks for normal exit the loop. Here is code fragment that implements the method, makes the various tests, and reports results. # now we begin the process count = 0 for i in range(0,HowMany,1): xnew = xnow - func(xnow)/dfdx(xnow) # stopping criteria -- update not changing if abs(xnew - xnow) < HowSmall: print (\"Update not changing \\n\") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) break else: xnow = xnew count = count +1 continue # stopping criteria -- function close to zero if abs( func(xnew) ) < HowSmall: print (\"Function value close to zero \\n\") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) break else: xnow = xnew count = count +1 continue # next step, then have either broken from the loop or iteration counted out if count == HowMany: print(\" Iteration Limit Reached \") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) print(\"End of NewtonMethod.py \") Iteration Limit Reached Function value = 3676.8081814664183 Root value = 8.235647852860856 End of NewtonMethod.py Now we simply connect the three fragments, and we would have a working Python script that implements Newton's method for the example equation. The example is specific to the particular function provided, but the programmer could move the two functions func and dfdx into a user specified module, and then load that module in the program to make it even more generic. The next section will use such an approach to illustrate the ability to build a generalized Newton method and only have to program the function itself","title":"Newton's Method: Using analytical derivative computation"},{"location":"solved-newton/NewtonsMethod/#newtons-method-finite-difference-to-derivative-estimate","text":"A practical difficulty in using Newton's method is determining the value of the derivative in cases where differentiation is difficult. In these cases we can replace the derivative by a finite difference equation and then proceed as in Newton's method. Recall from calculus that the derivative was defined as the limit of the difference quotient: \\begin{equation} \\frac{df}{dx}\\vert_{x} = \\lim_{\\Delta x \\rightarrow 0}\\frac{f(x + \\Delta x) - f(x) }{\\Delta x} \\end{equation} A good approximation to the derivative should be possible by using this formula with a small, but non-zero value for \\Delta x . \\begin{equation} \\frac{df}{dx}\\vert_{x} \\approx \\frac{f(x + \\Delta x) - f(x) }{\\Delta x} \\end{equation} When one replaces the derivative with the difference formula the root finding method the resulting update formula is \\begin{equation} x_{k+1}=x_k - \\frac{f(x_k) \\Delta x}{f(x_k + \\Delta x)-f(x_k)} \\end{equation} This root-finding method is called a quasi-Newton method. Here is the code fragment that we change by commenting out the analytical derivative and replacing it with a first-order finite difference approximation of the derivative. The numerical value 1e-06 is called the step size ( \\Delta x ) and should be an input value (rather than built-in to the code as shown here) like the tolerance test values, and be passed to the function as another argument. # reset the notebook %reset Once deleted, variables cannot be recovered. Proceed (y/[n])? y # import built in function for e^x, cosine from math import exp, cos, sin # Define the function def func(x): func = exp(x) - 10*cos(x) - 100 #using the name as the temp var return func def dfdx(x): # dfdx = exp(x) + 10*sin(x) dfdx = (func(x + 1e-06) - func(x) )/ (1e-06) return (dfdx) # Now for the Newton Method Implementation # Get initial guess, use a simple error trap yes=0 while yes == 0: xnow = input(\"Enter an initial guess for Newton method \\n\") try: xnow = float(xnow) yes =1 except: print (\"Value should be numeric, try again \\n\") # Get number trials, use a simple error trap yes=0 while yes == 0: HowMany = input(\"Enter iteration maximum \\n\") try: HowMany = int(HowMany) yes =1 except: print (\"Value should be numeric, try again \\n\") # Get stopping criterion yes=0 while yes == 0: HowSmall = input(\"Enter a solution tolerance (e.g. 1e-06) \\n\") try: HowSmall= float(HowSmall) yes =1 except: print (\"Value should be numeric, try again \\n\") Enter an initial guess for Newton method 2 Enter iteration maximum 33 Enter a solution tolerance (e.g. 1e-06) 1e-9 # now we begin the process count = 0 for i in range(0,HowMany,1): xnew = xnow - func(xnow)/dfdx(xnow) # stopping criteria -- update not changing if abs(xnew - xnow) < HowSmall: print (\"Update not changing \\n\") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) break else: xnow = xnew count = count +1 continue # stopping criteria -- function close to zero if abs( func(xnew) ) < HowSmall: print (\"Function value close to zero \\n\") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) break else: xnow = xnew count = count +1 continue # next step, then have either broken from the loop or iteration counted out if count == HowMany: print(\" Iteration Limit Reached \") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) print(\"End of NewtonMethod.py \") Update not changing Function value = 1.4210854715202004e-14 Root value = 4.593209147284144 End of NewtonMethod.py Pretty much the same result, but now we dont have to determine the analytical derivative.","title":"Newton's Method : Finite-difference to derivative estimate"},{"location":"solved-pipeline/NonLinearSystems/","text":"Nonlinear Systems of Equations Non-linear systems are extensions of the linear systems cases except the systems involve products and powers of the unknown variables. Non-linear problems are often quite difficult to manage, especially when the systems are large (many rows and many variables). The solution to non-linear systems, if non-trivial or even possible, are usually iterative. Within the iterative steps is a linearization component \u2013 these linear systems which are intermediate computations within the overall solution process are treated by an appropriate linear system method (direct or iterative). Consider the system below: \\begin{gather} \\begin{matrix} x^2 & +~y^2 \\\\ e^x & +~y \\\\ \\end{matrix} \\begin{matrix} = 4\\\\ = 1\\\\ \\end{matrix} \\end{gather} Suppose we have a solution guess x_{k},y_{k} , which of course could be wrong, but we could linearize about that guess as \\begin{gather} \\mathbf{A} = \\begin{pmatrix} x_k & + ~y_k \\\\ 0 & + ~1 \\\\ \\end{pmatrix} ~\\mathbf{x} = \\begin{pmatrix} x_{k+1} \\\\ y_{k+1} \\\\ \\end{pmatrix} ~ \\mathbf{b} = \\begin{pmatrix} 4\\\\ 1 - e^{x_k}\\\\ \\end{pmatrix} \\end{gather} Now if we assemble the system in the usual fashion, \\mathbf{A} \\cdot \\mathbf{x_{k+1}} = ~ \\mathbf{b}~ we have a system of linear equations\\footnote{Linear in \\mathbf{x_{k+1}} }, which expanded look like: \\begin{gather} \\begin{pmatrix} x_k & + ~y_k \\\\ 0 & + ~1 \\\\ \\end{pmatrix} \\cdot \\begin{pmatrix} x_{k+1} \\\\ y_{k+1} \\\\ \\end{pmatrix} ~ = \\begin{pmatrix} 4\\\\ 1 - e^{x_k}\\\\ \\end{pmatrix} \\end{gather} Now that the system is linear, and we can solve for \\mathbf{x_{k+1}} using our linear system solver for the new guess. If the system is convergent (not all are) then if we update, and repeat we will eventually find a result. What one really needs is a way to construct the linear system that has a systematic update method, that is discussed below Multiple-variable extension of Newton\u2019s Method This section presents the Newton-Raphson method as a way to sometimes solve systems of non-linear equations. Consider an example where the function \\textbf{f} is a vector-valued function of a vector argument. \\begin{gather} \\mathbf{f(x)} = \\begin{matrix} f_1 = & x^2 & +~y^2 & - 4\\\\ f_2 = & e^x & +~y & - 1\\\\ \\end{matrix} \\end{gather} Let's also recall Newtons method for scalar valued function of a single variable. \\begin{equation} x_{k+1}=x_{k} - \\frac{ f(x_{k}) }{ \\frac{df}{dx}\\rvert_{x_k} } \\label{eqn:NewtonFormula} \\end{equation} When extending to higher dimensions, the analog for x is the vector \\textbf{x} and the analog for the function f() is the vector function \\textbf{f()}. What remains is an analog for the first derivative in the denominator (and the concept of division of a matrix). The analog to the first derivative is a matrix called the Jacobian which is comprised of the first derivatives of the function \\textbf{f} with respect to the arguments \\textbf{x}. For example for a 2-value function of 2 arguments (as our example above) \\begin{equation} \\frac{df}{dx}\\rvert_{x_k} => \\begin{pmatrix} \\frac{\\partial f_1}{\\partial x_1} & \\frac{\\partial f_1}{\\partial x_2} \\\\ ~ & ~ \\\\ \\frac{\\partial f_2}{\\partial x_1} & \\frac{\\partial f_2}{\\partial x_2} \\\\ \\end{pmatrix} \\label{eqn:Jacobian} \\end{equation} Next recall that division is replaced by matrix multiplication with the multiplicative inverse, so the analogy continues as \\begin{equation} \\frac{1}{\\frac{df}{dx}\\rvert_{x_k}} => {\\begin{pmatrix} \\frac{\\partial f_1}{\\partial x_1} & \\frac{\\partial f_1}{\\partial x_2} \\\\ ~ & ~ \\\\ \\frac{\\partial f_2}{\\partial x_1} & \\frac{\\partial f_2}{\\partial x_2} \\\\ \\end{pmatrix}}^{-1} \\label{eqn:JacobianInverse} \\end{equation} Let's name the Jacobian \\textbf{J(x)}. So the multi-variate Newton's method can be written as \\begin{equation} \\mathbf{x}_{k+1}=\\mathbf{x}_{k} - \\mathbf{J(x)}^{-1}\\rvert_{x_k} \\cdot \\mathbf{f(x)}\\rvert_{x_k} \\label{eqn:VectorNewtonFormula} \\end{equation} In the linear systems lessons we did find a way to solve for an inverse, but it's not necessary, and is computationally expensive to invert in these examples -- a series of rearrangement of the system above yields a nice scheme that does not require inversion of a matrix. First, move the \\mathbf{x}_{k} to the left-hand side. \\begin{equation} \\mathbf{x}_{k+1}-\\mathbf{x}_{k} = - \\mathbf{J(x)}^{-1}\\rvert_{x_k} \\cdot \\mathbf{f(x)}\\rvert_{x_k} \\end{equation} Next multiply both sides by the Jacobian (The Jacobian must be non-singular otherwise we are dividing by zero) \\begin{equation} \\mathbf{J(x)}\\rvert_{x_k} \\cdot (\\mathbf{x}_{k+1}-\\mathbf{x}_{k}) = - \\mathbf{J(x)}\\rvert_{x_k} \\cdot \\mathbf{J(x)}^{-1}\\rvert_{x_k} \\cdot \\mathbf{f(x)}\\rvert_{x_k} \\end{equation} Recall a matrix multiplied by its inverse returns the identity matrix (the matrix equivalent of unity) \\begin{equation} -\\mathbf{J(x)}\\rvert_{x_k} \\cdot (\\mathbf{x}_{k+1}-\\mathbf{x}_{k}) = \\mathbf{f(x)}\\rvert_{x_k} \\end{equation} So we now have an algorithm: 1) Start with an initial guess \\mathbf{x}_{k} , compute \\mathbf{f(x)}\\rvert_{x_k} , and \\mathbf{J(x)}\\rvert_{x_k} . 2) Test for stopping. Is \\mathbf{f(x)}\\rvert_{x_k} close to zero? If yes, exit and report results, otherwise continue. 3) Solve the linear system \\mathbf{J(x)}\\rvert_{x_k} \\cdot (\\mathbf{x}_{k+1}-\\mathbf{x}_{k}) = \\mathbf{f(x)}\\rvert_{x_k} . 4) Test for stopping. Is (\\mathbf{x}_{k+1}-\\mathbf{x}_{k}) close to zero? If yes, exit and report results, otherwise continue. 5) Compute the update \\mathbf{x}_{k+1} = \\mathbf{x}_{k} - (\\mathbf{x}_{k+1}-\\mathbf{x}_{k}) , then 6) Move the update into the guess vector \\mathbf{x}_{k} <=\\mathbf{x}_{k+1} =and repeat step 1. Stop after too many steps. Example using Analytical Derivatives Now to complete the example we will employ this algorithm. The function (repeated) \\begin{gather} \\mathbf{f(x)} = \\begin{matrix} f_1 = & x^2 & +~y^2 & - 4\\\\ f_2 = & e^x & +~y & - 1\\\\ \\end{matrix} \\end{gather} Then the Jacobian, here we will compute it analytically because we can \\begin{equation} \\mathbf{J(x)}=> {\\begin{pmatrix} 2x & 2y \\\\ ~ & ~ \\\\ e^x & 1 \\\\ \\end{pmatrix}} \\end{equation} Now for the scripts. We will start by defining the two equations, and their derivatives, as well a a vector valued function func and its Jacobian jacob as below. Here the two modules LinearSolverPivot and vector_matrix_lib are just python source code files containing prototype functions. ################################################################# # Newton Solver Example -- Analytical Derivatives # ################################################################# import math # This will import math module from python distribution from LinearSolverPivot import linearsolver # This will import our solver module from vector_matrix_lib import writeM,writeV,vdotv,vvsub # This will import our vector functions def eq1(x,y): eq1 = x**2 + y**2 - 4.0 return(eq1) def eq2(x,y): eq2 = math.exp(x) + y - 1.0 return(eq2) def ddxeq1(x,y): ddxeq1 = 2.0*x return(ddxeq1) def ddyeq1(x,y): ddyeq1 = 2.0*y return(ddyeq1) def ddxeq2(x,y): ddxeq2 = math.exp(x) return(ddxeq2) def ddyeq2(x,y): ddyeq2 = 1.0 return(ddyeq2) def func(x,y): func = [0.0 for i in range(2)] # null list # build the function func[0] = eq1(x,y) func[1] = eq2(x,y) return(func) def jacob(x,y): jacob = [[0.0 for j in range(2)] for i in range(2)] # constructed list #build the jacobian jacob[0][0]=ddxeq1(x,y) jacob[0][1]=ddyeq1(x,y) jacob[1][0]=ddxeq2(x,y) jacob[1][1]=ddyeq2(x,y) return(jacob) Next we create vectors to store values, and supply initial guesses to the system, and echo the inputs. deltax = [0.0 for i in range(2)] # null list xguess = [0.0 for i in range(2)] # null list myfunc = [0.0 for i in range(2)] # null list myjacob = [[0.0 for j in range(2)] for i in range(2)] # constructed list # supply initial guess xguess[0] = float(input(\"Value for x : \")) xguess[1] = float(input(\"Value for y : \")) # build the initial function myfunc = func(xguess[0],xguess[1]) #build the initial jacobian myjacob=jacob(xguess[0],xguess[1]) #write initial results writeV(xguess,2,\"Initial X vector \") writeV(myfunc,2,\"Initial FUNC vector \") writeM(myjacob,2,2,\"Initial Jacobian \") # solver parameters tolerancef = 1.0e-9 tolerancex = 1.0e-9 Value for x : 2 Value for y : 3 ------ Initial X vector ------ 2.0 3.0 ----------------------------- ------ Initial FUNC vector ------ 9.0 9.38905609893065 ----------------------------- ------ Initial Jacobian ------ [4.0, 6.0] [7.38905609893065, 1.0] ----------------------------- Now we apply the algorithm a few times, here the count is set to 10. So eneter the loop, test for stopping, then update. # Newton-Raphson for iteration in range(10): myfunc = func(xguess[0],xguess[1]) testf = vdotv(myfunc,myfunc,2) if testf <= tolerancef : print(\"f(x) close to zero\\n test value : \", testf) break myjacob=jacob(xguess[0],xguess[1]) deltax=linearsolver(myjacob,myfunc) testx = vdotv(deltax,deltax,2) if testx <= tolerancex : print(\"solution change small\\n test value : \", testx) break xguess=vvsub(xguess,deltax,2) ## print(\"iteration : \",iteration) ## writeV(xguess,2,\"Current X vector \") ## writeV(myfunc,2,\"Current FUNC vector \") print(\"Exiting Iteration : \",iteration) writeV(xguess,2,\"Exiting X vector \") writeV(myfunc,2,\"Exiting FUNC vector \") f(x) close to zero test value : 4.741631714784361e-10 Exiting Iteration : 6 ------ Exiting X vector ------ -1.8162690125838175 0.8373700502918618 ----------------------------- ------ Exiting FUNC vector ------ 2.1727197990095704e-05 1.446388252723807e-06 ----------------------------- Quasi-Newton Method using Finite Difference Approximations for the Derivative The next variant is to approximate the derivatives -- usually a Finite-Difference approximation is used, either forward, backward, or centered differences -- generally determined based on the actual behavior of the functions themselves or by trial and error. For really huge systems, we usually make the program itself make the adaptions as it proceeds. The coding for a finite-difference representation of a Jacobian is shown in Listing that follows In constructing the Jacobian, we observe that each column of the Jacobian is simply the directional derivative of the function with respect to the variable associated with the column. For instance, the first column of the Jacobian in the example is first derivative of the first function (all rows) with respect to the first variable, in this case x . The second column is the first derivative of the second function with respect to the second variable, y . This structure is useful to generalize the Jacobian construction method because we could write (yet another) prototype function that can take the directional derivatives for us, and just insert the returns as columns; in the example we simply modified the ddx and ddy functions from analytical to simple finite differences. The example listing is specific to the 2X2 function in the example, but the extension to more general cases is evident. ################################################################# # Newton Solver Example -- Numerical Derivatives # ################################################################# import math # This will import math module from python distribution from LinearSolverPivot import linearsolver # This will import our solver module from vector_matrix_lib import writeM,writeV,vdotv,vvsub # This will import our vector functions def eq1(x,y): eq1 = x**2 + y**2 - 4.0 return(eq1) def eq2(x,y): eq2 = math.exp(x) + y - 1.0 return(eq2) ############################################################## # This portion is changed for finite-difference method to evaluate derivatives # ############################################################## def ddxeq1(x,y): delta = 1.0e-6 ddxeq1 = (eq1(x+delta,y)-eq1(x,y))/delta return(ddxeq1) def ddyeq1(x,y): delta = 1.0e-6 ddyeq1 = (eq1(x,y+delta)-eq1(x,y))/delta return(ddyeq1) def ddxeq2(x,y): delta = 1.0e-6 ddxeq2 = (eq2(x+delta,y)-eq2(x,y))/delta return(ddxeq2) def ddyeq2(x,y): delta = 1.0e-6 ddyeq2 = (eq2(x,y+delta)-eq2(x,y))/delta return(ddyeq2) ############################################################## def func(x,y): func = [0.0 for i in range(2)] # null list # build the function func[0] = eq1(x,y) func[1] = eq2(x,y) return(func) def jacob(x,y): jacob = [[0.0 for j in range(2)] for i in range(2)] # constructed list #build the jacobian jacob[0][0]=ddxeq1(x,y) jacob[0][1]=ddyeq1(x,y) jacob[1][0]=ddxeq2(x,y) jacob[1][1]=ddyeq2(x,y) return(jacob) deltax = [0.0 for i in range(2)] # null list xguess = [0.0 for i in range(2)] # null list myfunc = [0.0 for i in range(2)] # null list myjacob = [[0.0 for j in range(2)] for i in range(2)] # constructed list # supply initial guess xguess[0] = float(input(\"Value for x : \")) xguess[1] = float(input(\"Value for y : \")) # build the initial function myfunc = func(xguess[0],xguess[1]) #build the initial jacobian myjacob=jacob(xguess[0],xguess[1]) #write initial results writeV(xguess,2,\"Initial X vector \") writeV(myfunc,2,\"Initial FUNC vector \") writeM(myjacob,2,2,\"Initial Jacobian \") # solver parameters tolerancef = 1.0e-9 tolerancex = 1.0e-9 # Newton-Raphson for iteration in range(10): myfunc = func(xguess[0],xguess[1]) testf = vdotv(myfunc,myfunc,2) if testf <= tolerancef : print(\"f(x) close to zero\\n test value : \", testf) break myjacob=jacob(xguess[0],xguess[1]) deltax=linearsolver(myjacob,myfunc) testx = vdotv(deltax,deltax,2) if testx <= tolerancex : print(\"solution change small\\n test value : \", testx) break xguess=vvsub(xguess,deltax,2) ## print(\"iteration : \",iteration) ## writeV(xguess,2,\"Current X vector \") ## writeV(myfunc,2,\"Current FUNC vector \") print(\"Exiting Iteration : \",iteration) writeV(xguess,2,\"Exiting X vector \") writeV(myfunc,2,\"Exiting FUNC vector using Finite-Differences\") When we run the script: Value for x : 0 Value for y : 2 ------ Initial X vector ------ 0.0 2.0 ----------------------------- ------ Initial FUNC vector ------ 0.0 2.0 ----------------------------- ------ Initial Jacobian ------ [1.000088900582341e-06, 4.0000010006480125] [1.0000005001842283, 1.000000000139778] ----------------------------- f(x) close to zero test value : 1.124762923231742e-16 Exiting Iteration : 5 ------ Exiting X vector ------ -1.816264071231508 0.8373678009903361 ----------------------------- ------ Exiting FUNC vector using Finite-Differences ------ 1.0581842957435583e-08 7.077372021768724e-10 ----------------------------- vector_matrix_lib.py # vector_matrix_lib.py # suggested citation goes here # useful linear algebra tools import math # This will import math module def writeM(M,ir,jc,label): print (\"------\",label,\"------\") for i in range(0,ir,1): print (M[i][0:jc]) print (\"-----------------------------\") #return def writeV(V,ir,label): print (\"------\",label,\"------\") for i in range(0,ir,1): print (V[i]) print (\"-----------------------------\") #return def mmmult(amatrix,bmatrix,rowNumA,colNumA,rowNumB,colNumB): AB =[[0.0 for j in range(colNumB)] for i in range(rowNumA)] for i in range(0,rowNumA): for j in range(0,colNumB): for k in range(0,colNumA): AB[i][j]=AB[i][j]+amatrix[i][k]*bmatrix[k][j] return(AB) def mvmult(amatrix,xvector,rowNumA,colNumA): bvector=[0.0 for i in range(rowNumA)] for i in range(0,rowNumA): for j in range(0,1): for k in range(0,colNumA): bvector[i]=bvector[i]+amatrix[i][k]*xvector[k] return(bvector) def vvadd(avector,bvector,length): aplusb=[0.0 for i in range(length)] for i in range(length): aplusb[i] = avector[i] + bvector[i] return(aplusb) def vvsub(avector,bvector,length): aminusb=[0.0 for i in range(length)] for i in range(length): aminusb[i] = avector[i] - bvector[i] return(aminusb) def vdotv(avector,bvector,length): adotb=0.0 for i in range(length): adotb=adotb+avector[i]*bvector[i] return(adotb) LinearSolverPivot.py # SolveLinearSystem.py # linearsolver with pivoting adapted from # https://stackoverflow.com/questions/31957096/gaussian-elimination-with-pivoting-in-python/31959226 # Supply wrapper code to read A and b # Then solve Ax = b for x by Gaussian elimination with back substitution # Script preserves A matrix, and b vector ########## def linearsolver(A,b): n = len(A) # M = A #this is object to object equivalence # copy A into M element by element M=[[0.0 for jcol in range(n)]for irow in range(n)] for irow in range(n): for jcol in range(n): M[irow][jcol]=A[irow][jcol] i = 0 for x in M: x.append(b[i]) i += 1 for k in range(n): for i in range(k,n): if abs(M[i][k]) > abs(M[k][k]): M[k], M[i] = M[i],M[k] else: pass for j in range(k+1,n): q = float(M[j][k]) / M[k][k] for m in range(k, n+1): M[j][m] -= q * M[k][m] x = [0 for i in range(n)] x[n-1] =float(M[n-1][n])/M[n-1][n-1] for i in range (n-1,-1,-1): z = 0 for j in range(i+1,n): z = z + float(M[i][j])*x[j] x[i] = float(M[i][n] - z)/M[i][i] # print (x) return(x) #","title":"Nonlinear Systems of Equations"},{"location":"solved-pipeline/NonLinearSystems/#nonlinear-systems-of-equations","text":"Non-linear systems are extensions of the linear systems cases except the systems involve products and powers of the unknown variables. Non-linear problems are often quite difficult to manage, especially when the systems are large (many rows and many variables). The solution to non-linear systems, if non-trivial or even possible, are usually iterative. Within the iterative steps is a linearization component \u2013 these linear systems which are intermediate computations within the overall solution process are treated by an appropriate linear system method (direct or iterative). Consider the system below: \\begin{gather} \\begin{matrix} x^2 & +~y^2 \\\\ e^x & +~y \\\\ \\end{matrix} \\begin{matrix} = 4\\\\ = 1\\\\ \\end{matrix} \\end{gather} Suppose we have a solution guess x_{k},y_{k} , which of course could be wrong, but we could linearize about that guess as \\begin{gather} \\mathbf{A} = \\begin{pmatrix} x_k & + ~y_k \\\\ 0 & + ~1 \\\\ \\end{pmatrix} ~\\mathbf{x} = \\begin{pmatrix} x_{k+1} \\\\ y_{k+1} \\\\ \\end{pmatrix} ~ \\mathbf{b} = \\begin{pmatrix} 4\\\\ 1 - e^{x_k}\\\\ \\end{pmatrix} \\end{gather} Now if we assemble the system in the usual fashion, \\mathbf{A} \\cdot \\mathbf{x_{k+1}} = ~ \\mathbf{b}~ we have a system of linear equations\\footnote{Linear in \\mathbf{x_{k+1}} }, which expanded look like: \\begin{gather} \\begin{pmatrix} x_k & + ~y_k \\\\ 0 & + ~1 \\\\ \\end{pmatrix} \\cdot \\begin{pmatrix} x_{k+1} \\\\ y_{k+1} \\\\ \\end{pmatrix} ~ = \\begin{pmatrix} 4\\\\ 1 - e^{x_k}\\\\ \\end{pmatrix} \\end{gather} Now that the system is linear, and we can solve for \\mathbf{x_{k+1}} using our linear system solver for the new guess. If the system is convergent (not all are) then if we update, and repeat we will eventually find a result. What one really needs is a way to construct the linear system that has a systematic update method, that is discussed below","title":"Nonlinear Systems of Equations"},{"location":"solved-pipeline/NonLinearSystems/#multiple-variable-extension-of-newtons-method","text":"This section presents the Newton-Raphson method as a way to sometimes solve systems of non-linear equations. Consider an example where the function \\textbf{f} is a vector-valued function of a vector argument. \\begin{gather} \\mathbf{f(x)} = \\begin{matrix} f_1 = & x^2 & +~y^2 & - 4\\\\ f_2 = & e^x & +~y & - 1\\\\ \\end{matrix} \\end{gather} Let's also recall Newtons method for scalar valued function of a single variable. \\begin{equation} x_{k+1}=x_{k} - \\frac{ f(x_{k}) }{ \\frac{df}{dx}\\rvert_{x_k} } \\label{eqn:NewtonFormula} \\end{equation} When extending to higher dimensions, the analog for x is the vector \\textbf{x} and the analog for the function f() is the vector function \\textbf{f()}. What remains is an analog for the first derivative in the denominator (and the concept of division of a matrix). The analog to the first derivative is a matrix called the Jacobian which is comprised of the first derivatives of the function \\textbf{f} with respect to the arguments \\textbf{x}. For example for a 2-value function of 2 arguments (as our example above) \\begin{equation} \\frac{df}{dx}\\rvert_{x_k} => \\begin{pmatrix} \\frac{\\partial f_1}{\\partial x_1} & \\frac{\\partial f_1}{\\partial x_2} \\\\ ~ & ~ \\\\ \\frac{\\partial f_2}{\\partial x_1} & \\frac{\\partial f_2}{\\partial x_2} \\\\ \\end{pmatrix} \\label{eqn:Jacobian} \\end{equation} Next recall that division is replaced by matrix multiplication with the multiplicative inverse, so the analogy continues as \\begin{equation} \\frac{1}{\\frac{df}{dx}\\rvert_{x_k}} => {\\begin{pmatrix} \\frac{\\partial f_1}{\\partial x_1} & \\frac{\\partial f_1}{\\partial x_2} \\\\ ~ & ~ \\\\ \\frac{\\partial f_2}{\\partial x_1} & \\frac{\\partial f_2}{\\partial x_2} \\\\ \\end{pmatrix}}^{-1} \\label{eqn:JacobianInverse} \\end{equation} Let's name the Jacobian \\textbf{J(x)}. So the multi-variate Newton's method can be written as \\begin{equation} \\mathbf{x}_{k+1}=\\mathbf{x}_{k} - \\mathbf{J(x)}^{-1}\\rvert_{x_k} \\cdot \\mathbf{f(x)}\\rvert_{x_k} \\label{eqn:VectorNewtonFormula} \\end{equation} In the linear systems lessons we did find a way to solve for an inverse, but it's not necessary, and is computationally expensive to invert in these examples -- a series of rearrangement of the system above yields a nice scheme that does not require inversion of a matrix. First, move the \\mathbf{x}_{k} to the left-hand side. \\begin{equation} \\mathbf{x}_{k+1}-\\mathbf{x}_{k} = - \\mathbf{J(x)}^{-1}\\rvert_{x_k} \\cdot \\mathbf{f(x)}\\rvert_{x_k} \\end{equation} Next multiply both sides by the Jacobian (The Jacobian must be non-singular otherwise we are dividing by zero) \\begin{equation} \\mathbf{J(x)}\\rvert_{x_k} \\cdot (\\mathbf{x}_{k+1}-\\mathbf{x}_{k}) = - \\mathbf{J(x)}\\rvert_{x_k} \\cdot \\mathbf{J(x)}^{-1}\\rvert_{x_k} \\cdot \\mathbf{f(x)}\\rvert_{x_k} \\end{equation} Recall a matrix multiplied by its inverse returns the identity matrix (the matrix equivalent of unity) \\begin{equation} -\\mathbf{J(x)}\\rvert_{x_k} \\cdot (\\mathbf{x}_{k+1}-\\mathbf{x}_{k}) = \\mathbf{f(x)}\\rvert_{x_k} \\end{equation} So we now have an algorithm: 1) Start with an initial guess \\mathbf{x}_{k} , compute \\mathbf{f(x)}\\rvert_{x_k} , and \\mathbf{J(x)}\\rvert_{x_k} . 2) Test for stopping. Is \\mathbf{f(x)}\\rvert_{x_k} close to zero? If yes, exit and report results, otherwise continue. 3) Solve the linear system \\mathbf{J(x)}\\rvert_{x_k} \\cdot (\\mathbf{x}_{k+1}-\\mathbf{x}_{k}) = \\mathbf{f(x)}\\rvert_{x_k} . 4) Test for stopping. Is (\\mathbf{x}_{k+1}-\\mathbf{x}_{k}) close to zero? If yes, exit and report results, otherwise continue. 5) Compute the update \\mathbf{x}_{k+1} = \\mathbf{x}_{k} - (\\mathbf{x}_{k+1}-\\mathbf{x}_{k}) , then 6) Move the update into the guess vector \\mathbf{x}_{k} <=\\mathbf{x}_{k+1} =and repeat step 1. Stop after too many steps.","title":"Multiple-variable extension of Newton\u2019s Method"},{"location":"solved-pipeline/NonLinearSystems/#example-using-analytical-derivatives","text":"Now to complete the example we will employ this algorithm. The function (repeated) \\begin{gather} \\mathbf{f(x)} = \\begin{matrix} f_1 = & x^2 & +~y^2 & - 4\\\\ f_2 = & e^x & +~y & - 1\\\\ \\end{matrix} \\end{gather} Then the Jacobian, here we will compute it analytically because we can \\begin{equation} \\mathbf{J(x)}=> {\\begin{pmatrix} 2x & 2y \\\\ ~ & ~ \\\\ e^x & 1 \\\\ \\end{pmatrix}} \\end{equation} Now for the scripts. We will start by defining the two equations, and their derivatives, as well a a vector valued function func and its Jacobian jacob as below. Here the two modules LinearSolverPivot and vector_matrix_lib are just python source code files containing prototype functions. ################################################################# # Newton Solver Example -- Analytical Derivatives # ################################################################# import math # This will import math module from python distribution from LinearSolverPivot import linearsolver # This will import our solver module from vector_matrix_lib import writeM,writeV,vdotv,vvsub # This will import our vector functions def eq1(x,y): eq1 = x**2 + y**2 - 4.0 return(eq1) def eq2(x,y): eq2 = math.exp(x) + y - 1.0 return(eq2) def ddxeq1(x,y): ddxeq1 = 2.0*x return(ddxeq1) def ddyeq1(x,y): ddyeq1 = 2.0*y return(ddyeq1) def ddxeq2(x,y): ddxeq2 = math.exp(x) return(ddxeq2) def ddyeq2(x,y): ddyeq2 = 1.0 return(ddyeq2) def func(x,y): func = [0.0 for i in range(2)] # null list # build the function func[0] = eq1(x,y) func[1] = eq2(x,y) return(func) def jacob(x,y): jacob = [[0.0 for j in range(2)] for i in range(2)] # constructed list #build the jacobian jacob[0][0]=ddxeq1(x,y) jacob[0][1]=ddyeq1(x,y) jacob[1][0]=ddxeq2(x,y) jacob[1][1]=ddyeq2(x,y) return(jacob) Next we create vectors to store values, and supply initial guesses to the system, and echo the inputs. deltax = [0.0 for i in range(2)] # null list xguess = [0.0 for i in range(2)] # null list myfunc = [0.0 for i in range(2)] # null list myjacob = [[0.0 for j in range(2)] for i in range(2)] # constructed list # supply initial guess xguess[0] = float(input(\"Value for x : \")) xguess[1] = float(input(\"Value for y : \")) # build the initial function myfunc = func(xguess[0],xguess[1]) #build the initial jacobian myjacob=jacob(xguess[0],xguess[1]) #write initial results writeV(xguess,2,\"Initial X vector \") writeV(myfunc,2,\"Initial FUNC vector \") writeM(myjacob,2,2,\"Initial Jacobian \") # solver parameters tolerancef = 1.0e-9 tolerancex = 1.0e-9 Value for x : 2 Value for y : 3 ------ Initial X vector ------ 2.0 3.0 ----------------------------- ------ Initial FUNC vector ------ 9.0 9.38905609893065 ----------------------------- ------ Initial Jacobian ------ [4.0, 6.0] [7.38905609893065, 1.0] ----------------------------- Now we apply the algorithm a few times, here the count is set to 10. So eneter the loop, test for stopping, then update. # Newton-Raphson for iteration in range(10): myfunc = func(xguess[0],xguess[1]) testf = vdotv(myfunc,myfunc,2) if testf <= tolerancef : print(\"f(x) close to zero\\n test value : \", testf) break myjacob=jacob(xguess[0],xguess[1]) deltax=linearsolver(myjacob,myfunc) testx = vdotv(deltax,deltax,2) if testx <= tolerancex : print(\"solution change small\\n test value : \", testx) break xguess=vvsub(xguess,deltax,2) ## print(\"iteration : \",iteration) ## writeV(xguess,2,\"Current X vector \") ## writeV(myfunc,2,\"Current FUNC vector \") print(\"Exiting Iteration : \",iteration) writeV(xguess,2,\"Exiting X vector \") writeV(myfunc,2,\"Exiting FUNC vector \") f(x) close to zero test value : 4.741631714784361e-10 Exiting Iteration : 6 ------ Exiting X vector ------ -1.8162690125838175 0.8373700502918618 ----------------------------- ------ Exiting FUNC vector ------ 2.1727197990095704e-05 1.446388252723807e-06 -----------------------------","title":"Example using Analytical Derivatives"},{"location":"solved-pipeline/NonLinearSystems/#quasi-newton-method-using-finite-difference-approximations-for-the-derivative","text":"The next variant is to approximate the derivatives -- usually a Finite-Difference approximation is used, either forward, backward, or centered differences -- generally determined based on the actual behavior of the functions themselves or by trial and error. For really huge systems, we usually make the program itself make the adaptions as it proceeds. The coding for a finite-difference representation of a Jacobian is shown in Listing that follows In constructing the Jacobian, we observe that each column of the Jacobian is simply the directional derivative of the function with respect to the variable associated with the column. For instance, the first column of the Jacobian in the example is first derivative of the first function (all rows) with respect to the first variable, in this case x . The second column is the first derivative of the second function with respect to the second variable, y . This structure is useful to generalize the Jacobian construction method because we could write (yet another) prototype function that can take the directional derivatives for us, and just insert the returns as columns; in the example we simply modified the ddx and ddy functions from analytical to simple finite differences. The example listing is specific to the 2X2 function in the example, but the extension to more general cases is evident. ################################################################# # Newton Solver Example -- Numerical Derivatives # ################################################################# import math # This will import math module from python distribution from LinearSolverPivot import linearsolver # This will import our solver module from vector_matrix_lib import writeM,writeV,vdotv,vvsub # This will import our vector functions def eq1(x,y): eq1 = x**2 + y**2 - 4.0 return(eq1) def eq2(x,y): eq2 = math.exp(x) + y - 1.0 return(eq2) ############################################################## # This portion is changed for finite-difference method to evaluate derivatives # ############################################################## def ddxeq1(x,y): delta = 1.0e-6 ddxeq1 = (eq1(x+delta,y)-eq1(x,y))/delta return(ddxeq1) def ddyeq1(x,y): delta = 1.0e-6 ddyeq1 = (eq1(x,y+delta)-eq1(x,y))/delta return(ddyeq1) def ddxeq2(x,y): delta = 1.0e-6 ddxeq2 = (eq2(x+delta,y)-eq2(x,y))/delta return(ddxeq2) def ddyeq2(x,y): delta = 1.0e-6 ddyeq2 = (eq2(x,y+delta)-eq2(x,y))/delta return(ddyeq2) ############################################################## def func(x,y): func = [0.0 for i in range(2)] # null list # build the function func[0] = eq1(x,y) func[1] = eq2(x,y) return(func) def jacob(x,y): jacob = [[0.0 for j in range(2)] for i in range(2)] # constructed list #build the jacobian jacob[0][0]=ddxeq1(x,y) jacob[0][1]=ddyeq1(x,y) jacob[1][0]=ddxeq2(x,y) jacob[1][1]=ddyeq2(x,y) return(jacob) deltax = [0.0 for i in range(2)] # null list xguess = [0.0 for i in range(2)] # null list myfunc = [0.0 for i in range(2)] # null list myjacob = [[0.0 for j in range(2)] for i in range(2)] # constructed list # supply initial guess xguess[0] = float(input(\"Value for x : \")) xguess[1] = float(input(\"Value for y : \")) # build the initial function myfunc = func(xguess[0],xguess[1]) #build the initial jacobian myjacob=jacob(xguess[0],xguess[1]) #write initial results writeV(xguess,2,\"Initial X vector \") writeV(myfunc,2,\"Initial FUNC vector \") writeM(myjacob,2,2,\"Initial Jacobian \") # solver parameters tolerancef = 1.0e-9 tolerancex = 1.0e-9 # Newton-Raphson for iteration in range(10): myfunc = func(xguess[0],xguess[1]) testf = vdotv(myfunc,myfunc,2) if testf <= tolerancef : print(\"f(x) close to zero\\n test value : \", testf) break myjacob=jacob(xguess[0],xguess[1]) deltax=linearsolver(myjacob,myfunc) testx = vdotv(deltax,deltax,2) if testx <= tolerancex : print(\"solution change small\\n test value : \", testx) break xguess=vvsub(xguess,deltax,2) ## print(\"iteration : \",iteration) ## writeV(xguess,2,\"Current X vector \") ## writeV(myfunc,2,\"Current FUNC vector \") print(\"Exiting Iteration : \",iteration) writeV(xguess,2,\"Exiting X vector \") writeV(myfunc,2,\"Exiting FUNC vector using Finite-Differences\") When we run the script: Value for x : 0 Value for y : 2 ------ Initial X vector ------ 0.0 2.0 ----------------------------- ------ Initial FUNC vector ------ 0.0 2.0 ----------------------------- ------ Initial Jacobian ------ [1.000088900582341e-06, 4.0000010006480125] [1.0000005001842283, 1.000000000139778] ----------------------------- f(x) close to zero test value : 1.124762923231742e-16 Exiting Iteration : 5 ------ Exiting X vector ------ -1.816264071231508 0.8373678009903361 ----------------------------- ------ Exiting FUNC vector using Finite-Differences ------ 1.0581842957435583e-08 7.077372021768724e-10 -----------------------------","title":"Quasi-Newton Method using Finite Difference Approximations for the Derivative"},{"location":"solved-pipeline/NonLinearSystems/#vector_matrix_libpy","text":"# vector_matrix_lib.py # suggested citation goes here # useful linear algebra tools import math # This will import math module def writeM(M,ir,jc,label): print (\"------\",label,\"------\") for i in range(0,ir,1): print (M[i][0:jc]) print (\"-----------------------------\") #return def writeV(V,ir,label): print (\"------\",label,\"------\") for i in range(0,ir,1): print (V[i]) print (\"-----------------------------\") #return def mmmult(amatrix,bmatrix,rowNumA,colNumA,rowNumB,colNumB): AB =[[0.0 for j in range(colNumB)] for i in range(rowNumA)] for i in range(0,rowNumA): for j in range(0,colNumB): for k in range(0,colNumA): AB[i][j]=AB[i][j]+amatrix[i][k]*bmatrix[k][j] return(AB) def mvmult(amatrix,xvector,rowNumA,colNumA): bvector=[0.0 for i in range(rowNumA)] for i in range(0,rowNumA): for j in range(0,1): for k in range(0,colNumA): bvector[i]=bvector[i]+amatrix[i][k]*xvector[k] return(bvector) def vvadd(avector,bvector,length): aplusb=[0.0 for i in range(length)] for i in range(length): aplusb[i] = avector[i] + bvector[i] return(aplusb) def vvsub(avector,bvector,length): aminusb=[0.0 for i in range(length)] for i in range(length): aminusb[i] = avector[i] - bvector[i] return(aminusb) def vdotv(avector,bvector,length): adotb=0.0 for i in range(length): adotb=adotb+avector[i]*bvector[i] return(adotb)","title":"vector_matrix_lib.py"},{"location":"solved-pipeline/NonLinearSystems/#linearsolverpivotpy","text":"# SolveLinearSystem.py # linearsolver with pivoting adapted from # https://stackoverflow.com/questions/31957096/gaussian-elimination-with-pivoting-in-python/31959226 # Supply wrapper code to read A and b # Then solve Ax = b for x by Gaussian elimination with back substitution # Script preserves A matrix, and b vector ########## def linearsolver(A,b): n = len(A) # M = A #this is object to object equivalence # copy A into M element by element M=[[0.0 for jcol in range(n)]for irow in range(n)] for irow in range(n): for jcol in range(n): M[irow][jcol]=A[irow][jcol] i = 0 for x in M: x.append(b[i]) i += 1 for k in range(n): for i in range(k,n): if abs(M[i][k]) > abs(M[k][k]): M[k], M[i] = M[i],M[k] else: pass for j in range(k+1,n): q = float(M[j][k]) / M[k][k] for m in range(k, n+1): M[j][m] -= q * M[k][m] x = [0 for i in range(n)] x[n-1] =float(M[n-1][n])/M[n-1][n-1] for i in range (n-1,-1,-1): z = 0 for j in range(i+1,n): z = z + float(M[i][j])*x[j] x[i] = float(M[i][n] - z)/M[i][i] # print (x) return(x) #","title":"LinearSolverPivot.py"}]}